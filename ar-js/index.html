<!DOCTYPE html>
<html>
  <script src="https://aframe.io/releases/1.0.0/aframe.min.js"></script>
  <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar.js"></script>

  <script>
    // â˜… æ§‹é€ è§£æãƒ‡ãƒ¼ã‚¿
    let MOLECULE_GRAPH = { atoms: [], bonds: [] }; 

    // å®šæ•°å®šç¾©
    const ATOM_BOND_THRESHOLD = 3.0; 
    const MULTIPLE_BOND_ATOM_THRESHOLD = 3.0; 
    const LATERAL_DISTANCE_THRESHOLD = 1.0; 
    const H_DIRECTION_TOLERANCE = 1.0; 
    const BOND_RADIUS = 0.05; 
    const MULTIPLE_BOND_OFFSET = 0.08; 

    // å‘½åç”¨ãƒ‡ãƒ¼ã‚¿
    const ALKANE_NAMES = ["", "ãƒ¡ã‚¿ãƒ³", "ã‚¨ã‚¿ãƒ³", "ãƒ—ãƒ­ãƒ‘ãƒ³", "ãƒ–ã‚¿ãƒ³", "ãƒšãƒ³ã‚¿ãƒ³", "ãƒ˜ã‚­ã‚µãƒ³", "ãƒ˜ãƒ—ã‚¿ãƒ³", "ã‚ªã‚¯ã‚¿ãƒ³", "ãƒãƒŠãƒ³", "ãƒ‡ã‚«ãƒ³"];
    const ALKYL_NAMES = ["", "ãƒ¡ãƒãƒ«", "ã‚¨ãƒãƒ«", "ãƒ—ãƒ­ãƒ”ãƒ«", "ãƒ–ãƒãƒ«", "ãƒšãƒ³ãƒãƒ«", "ãƒ˜ã‚­ã‚·ãƒ«"]; // å´é–ç”¨
    const NUMERAL_PREFIXES = ["", "", "ã‚¸", "ãƒˆãƒª", "ãƒ†ãƒˆãƒ©", "ãƒšãƒ³ã‚¿", "ãƒ˜ã‚­ã‚µ"]; // å€æ•°æ¥é ­è¾

    // å®˜èƒ½åŸºå®šç¾©
    const FUNCTIONAL_GROUPS = [
        { name: "ã‚«ãƒ«ãƒœãƒ³é…¸", suffix: "é…¸", priority: 1, type: "CARBOXYLIC" },
        { name: "ã‚¢ãƒ«ãƒ‡ãƒ’ãƒ‰", suffix: "ã‚¢ãƒ¼ãƒ«", priority: 2, type: "ALDEHYDE" },
        { name: "ã‚±ãƒˆãƒ³", suffix: "ã‚ªãƒ³", priority: 3, type: "KETONE" },
        { name: "ã‚¢ãƒ«ã‚³ãƒ¼ãƒ«", suffix: "ã‚ªãƒ¼ãƒ«", priority: 4, type: "ALCOHOL" },
        { name: "ã‚¢ãƒ«ã‚­ãƒ³", suffix: "ã‚¤ãƒ³", priority: 5, type: "ALKYNE" }, // ä¸»é–åã®ä¸€éƒ¨ã‚’å¤‰å½¢
        { name: "ã‚¢ãƒ«ã‚±ãƒ³", suffix: "ã‚¨ãƒ³", priority: 6, type: "ALKENE" }, // ä¸»é–åã®ä¸€éƒ¨ã‚’å¤‰å½¢
        { name: "ã‚¨ãƒ¼ãƒ†ãƒ«", suffix: "", priority: 7, type: "ETHER" }, // æ¥é ­è¾æ‰±ã„
        { name: "ã‚¢ãƒ«ã‚«ãƒ³", suffix: "ã‚¢ãƒ³", priority: 8, type: "ALKANE" }
    ];

    // â˜…â˜…â˜… æ–°æ©Ÿèƒ½: æ…£ç”¨åãƒ‡ãƒ¼ã‚¿ (æ‰‹å‹•è¿½åŠ ) â˜…â˜…â˜…
    // â˜…â˜…â˜… ä¿®æ­£ç®‡æ‰€ 1: æ…£ç”¨åãƒ‡ãƒ¼ã‚¿ (æ§‹é€ ã‚’å¤‰æ›´ã—ã€å‚™è€ƒæ¬„ã‚’è¿½åŠ ) â˜…â˜…â˜…
    // ã‚­ãƒ¼: ç”Ÿæˆã•ã‚ŒãŸIUPACå
    // å€¤: { name: æ…£ç”¨å, note: å‚™è€ƒ }
    const COMMON_NAMES = {
        "ãƒ¡ã‚¿ãƒ³é…¸": { 
            name: "ã‚®é…¸ (Formic Acid)", 
            note: "ğŸœ ãƒ©ãƒ†ãƒ³èªã§ã€Œã‚¢ãƒªã€ã‚’æ„å‘³ã™ã‚‹ Formica ãŒèªæºã€‚ã‚¢ãƒªãŒå¤–æ•µã‹ã‚‰èº«ã‚’å®ˆã‚‹ãŸã‚ã«åˆ†æ³Œã—ã¾ã™ã€‚" 
        },
        "ã‚¨ã‚¿ãƒ³é…¸": { 
            name: "é…¢é…¸ (Acetic Acid)", 
            note: "ãƒ©ãƒ†ãƒ³èªã§ã€Œé…¢ã€ã‚’æ„å‘³ã™ã‚‹ Acetum ãŒèªæºã€‚é…¢ã®ä¸»æˆåˆ†ã§ã‚ã‚Šã€é…¸å‘³ã®ã‚‚ã¨ã§ã™ã€‚" 
        },
        "ãƒ–ã‚¿ãƒ³é…¸": { 
            name: "é…ªé…¸ (Butyric Acid)", 
            note: "ğŸ§ˆ ãƒ©ãƒ†ãƒ³èªã§ã€Œãƒã‚¿ãƒ¼ã€ã‚’æ„å‘³ã™ã‚‹ Butyrum ãŒèªæºã€‚ãƒã‚¿ãƒ¼ã‚„ã€æ±—ã€éŠ€æã«å«ã¾ã‚Œã‚‹ä¸å¿«ãªè‡­ã„ã®åŸå› ç‰©è³ªã§ã™ã€‚" 
        },
        "ã‚¨ã‚¿ãƒ³-1-ã‚ªãƒ¼ãƒ«": { 
            name: "ã‚¨ãƒãƒ«ã‚¢ãƒ«ã‚³ãƒ¼ãƒ«ã€ã‚¨ã‚¿ãƒãƒ¼ãƒ« (Ethanol)", 
            note: "ğŸº é£²ç”¨ã•ã‚Œã‚‹ã‚¢ãƒ«ã‚³ãƒ¼ãƒ«ã€‚ç™ºé…µã«ã‚ˆã£ã¦ä½œã‚‰ã‚Œã¾ã™ã€‚" 
        },
        "ãƒ¡ã‚¿ãƒ³-1-ã‚ªãƒ¼ãƒ«": { 
            name: "ãƒ¡ãƒãƒ«ã‚¢ãƒ«ã‚³ãƒ¼ãƒ«ã€ãƒ¡ã‚¿ãƒãƒ¼ãƒ« (Methanol)", 
            note: "ğŸªµ ã‹ã¤ã¦æœ¨æã®ä¹¾ç•™ã«ã‚ˆã£ã¦è£½é€ ã•ã‚Œã¦ã„ãŸãŸã‚ã€Œæœ¨ç²¾ï¼ˆã‚‚ãã›ã„ï¼‰ã€ã¨ã‚‚å‘¼ã°ã‚Œã¾ã™ã€‚æ¯’æ€§ãŒéå¸¸ã«å¼·ã„ã§ã™ã€‚" 
        },
        "ãƒ—ãƒ­ãƒ‘ãƒ³-2-ã‚ªãƒ¼ãƒ«": { 
            name: "ã‚¤ã‚½ãƒ—ãƒ­ãƒ”ãƒ«ã‚¢ãƒ«ã‚³ãƒ¼ãƒ«ã€2-ãƒ—ãƒ­ãƒ‘ãƒãƒ¼ãƒ« (Isopropanol)", 
            note: "ğŸ§¼ æ¶ˆæ¯’æ¶²ã‚„æ´—æµ„æ¶²ã¨ã—ã¦å¹…åºƒãä½¿ã‚ã‚Œã¾ã™ã€‚ã‚±ãƒˆãƒ³ä½“ã®ã‚¢ã‚»ãƒˆãƒ³ã¨ç›¸äº’å¤‰æ›ã®é–¢ä¿‚ã«ã‚ã‚Šã¾ã™ã€‚" 
        },
        "ã‚¨ã‚¿-1-ã‚¨ãƒ³": { 
            name: "ã‚¨ãƒãƒ¬ãƒ³ (Ethylene)", 
            note: "ğŸŒ æ¤ç‰©ãƒ›ãƒ«ãƒ¢ãƒ³ã¨ã—ã¦åƒãã€æœç‰©ã®æˆç†Ÿï¼ˆè¿½ç†Ÿï¼‰ã‚’ä¿ƒé€²ã™ã‚‹ä½œç”¨ãŒã‚ã‚Šã¾ã™ã€‚æœ€ã‚‚ç°¡å˜ãªã‚¢ãƒ«ã‚±ãƒ³ã§ã™ã€‚" 
        },
        "ã‚¨ã‚¿-1-ã‚¤ãƒ³": { 
            name: "ã‚¢ã‚»ãƒãƒ¬ãƒ³ (Acetylene)", 
            note: "ğŸ”¥ é…¸ç´ ã¨æ··ãœã‚‹ã¨ç´„3,300â„ƒã®é«˜æ¸©ãŒå¾—ã‚‰ã‚Œã‚‹ãŸã‚ã€ã‚¬ã‚¹æº¶æ¥ã‚„åˆ‡æ–­ã«æ¬ ã‹ã›ãªã„ç‡ƒæ–™ã‚¬ã‚¹ã¨ã—ã¦ä½¿ã‚ã‚Œã¾ã™ã€‚" 
        },
        "ãƒ—ãƒ­ãƒ‘ãƒ³-2-ã‚ªãƒ³": { 
            name: "ã‚¢ã‚»ãƒˆãƒ³ (Acetone)", 
            note: "ğŸ’… æœ€ã‚‚ç°¡å˜ãªã‚±ãƒˆãƒ³ã€‚æ²¹ã‚’ã‚ˆãæº¶ã‹ã—ã€äººä½“ã¸ã®æ¯’æ€§ã‚‚ä½ã„ã“ã¨ã‹ã‚‰ã€é™¤å…‰æ¶²ã‚„æœ‰æ©Ÿæº¶åª’ã¨ã—ã¦å¤šç”¨ã•ã‚Œã¾ã™ã€‚" 
        },
        "ãƒ¡ã‚¿ãƒ³ã‚¢ãƒ¼ãƒ«": { 
            name: "ãƒ›ãƒ«ãƒ ã‚¢ãƒ«ãƒ‡ãƒ’ãƒ‰ (Formaldehyde)", 
            note: "ğŸ¦  37%æ°´æº¶æ¶²ãŒãƒ›ãƒ«ãƒãƒªãƒ³ã¨å‘¼ã°ã‚Œã€é˜²è…å‰¤ã‚„æ¶ˆæ¯’å‰¤ã¨ã—ã¦åˆ©ç”¨ã•ã‚Œã¾ã™ã€‚åˆºæ¿€è‡­ãŒã‚ã‚Šã¾ã™ã€‚" 
        },
        "ã‚¨ã‚¿ãƒ³ã‚¢ãƒ¼ãƒ«": { 
            name: "ã‚¢ã‚»ãƒˆã‚¢ãƒ«ãƒ‡ãƒ’ãƒ‰ (Formaldehyde)", 
            note: "ğŸ¦  37%æ°´æº¶æ¶²ãŒãƒ›ãƒ«ãƒãƒªãƒ³ã¨å‘¼ã°ã‚Œã€é˜²è…å‰¤ã‚„æ¶ˆæ¯’å‰¤ã¨ã—ã¦åˆ©ç”¨ã•ã‚Œã¾ã™ã€‚åˆºæ¿€è‡­ãŒã‚ã‚Šã¾ã™ã€‚" 
        }

        // å¿…è¦ã«å¿œã˜ã¦ã“ã“ã«æ–°ã—ã„æ…£ç”¨åã¨å‚™è€ƒã‚’è¿½åŠ ã—ã¦ãã ã•ã„
    };

    // --- ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°ç¾¤ ---
    function getValence(atomType) {
      if (atomType === 'C') return 4;
      if (atomType === 'H') return 1;
      if (atomType === 'O') return 2;
      return 0;
    }

    function getAtomType(markerId) {
      if (!markerId) return 'unknown';
      if (markerId.startsWith('carbon')) return 'C'; 
      if (markerId.startsWith('hydrogen')) return 'H';
      if (markerId.startsWith('oxygen')) return 'O';
      if (markerId.startsWith('double')) return 'double-bond';
      if (markerId.startsWith('triple')) return 'triple-bond';
      return 'unknown'; 
    }
    
    function createBondCylinder(startPos, endPos, radius, color, offset, bondOrder) {
        const dx = startPos.x - endPos.x;
        const dy = startPos.y - endPos.y;
        const dz = startPos.z - endPos.z;
        const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
        const midPos = {
            x: (startPos.x + endPos.x) / 2 + (offset * (dy/distance || 0)),
            y: (startPos.y + endPos.y) / 2 + (offset * (-dx/distance || 0)),
            z: (startPos.z + endPos.z) / 2, 
        };
        const rotationY = Math.atan2(dx, dy) * (180 / Math.PI);
        const cylinder = document.createElement('a-cylinder');
        cylinder.setAttribute('radius', radius);
        cylinder.setAttribute('height', distance);
        cylinder.setAttribute('color', color);
        cylinder.setAttribute('position', `${midPos.x} ${midPos.y} ${midPos.z}`);
        cylinder.setAttribute('rotation', `0 0 ${-rotationY}`); 
        cylinder.setAttribute('data-bond-order', bondOrder);
        return cylinder;
    }

    function registerBond(atomA, atomB, bondValue) {
        if ((atomA.type === 'H' || atomB.type === 'H') && bondValue > 1) bondValue = 1;
        if (atomA.valenceUsed + bondValue > getValence(atomA.type) || atomB.valenceUsed + bondValue > getValence(atomB.type)) return false; 
        let isAlreadyBonded = MOLECULE_GRAPH.bonds.some(b => (b.atom1 === atomA.atomIndex && b.atom2 === atomB.atomIndex) || (b.atom2 === atomA.atomIndex && b.atom1 === atomB.atomIndex));
        if (isAlreadyBonded) return false;

        MOLECULE_GRAPH.bonds.push({
            atom1: atomA.atomIndex, atom2: atomB.atomIndex, order: bondValue, 
            type: bondValue === 1 ? '-' : (bondValue === 2 ? '=' : 'â‰¡'),
            atomAEl: atomA.markerEl, atomBEl: atomB.markerEl
        });
        atomA.valenceUsed += bondValue;
        atomB.valenceUsed += bondValue;
        return true;
    }
    
    function toMarkerLocalCoords(marker, globalPos) {
        const markerPos = marker.object3D.position;
        const rotation = marker.object3D.rotation.z; 
        const dx = globalPos.x - markerPos.x;
        const dy = globalPos.y - markerPos.y;
        const dz = globalPos.z - markerPos.z;
        const cos = Math.cos(-rotation);
        const sin = Math.sin(-rotation);
        return { x: dx * cos - dy * sin, y: dx * sin + dy * cos, z: dz };
    }

    // â˜…â˜…â˜… 1. æœ€é•·ç‚­ç´ é–ã®ã€Œãƒ‘ã‚¹ï¼ˆåŸå­ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹é…åˆ—ï¼‰ã€ã‚’å–å¾—ã™ã‚‹é–¢æ•° â˜…â˜…â˜…
    function findLongestChainPath(detectedAtoms, moleculeGraph) {
        const carbonIndices = detectedAtoms.map((a, i) => a.isCarbon ? i : -1).filter(i => i !== -1);
        if (carbonIndices.length === 0) return [];

        // éš£æ¥ãƒªã‚¹ãƒˆä½œæˆ
        const adjacency = {};
        carbonIndices.forEach(i => adjacency[i] = []);
        moleculeGraph.bonds.forEach(bond => {
            if (detectedAtoms[bond.atom1].isCarbon && detectedAtoms[bond.atom2].isCarbon) {
                adjacency[bond.atom1].push(bond.atom2);
                adjacency[bond.atom2].push(bond.atom1);
            }
        });

        let longestPath = [];

        function dfs(currentPath) {
            const currentNode = currentPath[currentPath.length - 1];
            const neighbors = adjacency[currentNode];
            let isLeaf = true;

            for (const neighbor of neighbors) {
                if (!currentPath.includes(neighbor)) {
                    isLeaf = false;
                    dfs([...currentPath, neighbor]);
                }
            }

            if (isLeaf) {
                if (currentPath.length > longestPath.length) {
                    longestPath = currentPath;
                }
            }
        }

        carbonIndices.forEach(startIndex => dfs([startIndex]));
        return longestPath;
    }

    // â˜…â˜…â˜… 2. ä¸»è¦å®˜èƒ½åŸºã®ç‰¹å®š (ä½ç½®æƒ…å ±ä»˜ã) â˜…â˜…â˜…
    function identifyPrincipalGroup(detectedAtoms, bonds, mainChainPath) {
        let candidates = [];
        
        // çµåˆæƒ…å ±ã‹ã‚‰éš£æ¥ãƒãƒƒãƒ—ä½œæˆ
        const getNeighbors = (idx) => {
            const n = [];
            bonds.forEach(b => {
                if (b.atom1 === idx) n.push({idx: b.atom2, order: b.order});
                else if (b.atom2 === idx) n.push({idx: b.atom1, order: b.order});
            });
            return n;
        };

        // ä¸»é–ä¸Šã®å„ç‚­ç´ ã«ã¤ã„ã¦å®˜èƒ½åŸºã‚’ãƒã‚§ãƒƒã‚¯
        mainChainPath.forEach(cIndex => {
            const neighbors = getNeighbors(cIndex);
            const atomC = detectedAtoms[cIndex];

            // ã‚«ãƒ«ãƒœãƒ‹ãƒ«ç³»
            const doubleO = neighbors.find(n => detectedAtoms[n.idx].isOxygen && n.order === 2);
            if (doubleO) {
                // ã‚«ãƒ«ãƒœãƒ³é…¸ (-COOH)
                const singleO = neighbors.find(n => detectedAtoms[n.idx].isOxygen && n.order === 1);
                if (singleO) {
                    const oNeighbors = getNeighbors(singleO.idx);
                    if (oNeighbors.some(n => detectedAtoms[n.idx].isHydrogen)) {
                        candidates.push({ group: FUNCTIONAL_GROUPS.find(g => g.type === "CARBOXYLIC"), atomIndex: cIndex });
                        return;
                    }
                }
                // ã‚¢ãƒ«ãƒ‡ãƒ’ãƒ‰ (-CHO)
                // ç«¯ã®ç‚­ç´ (ä¸»é–ä¸Šã§ã®éš£æ¥ãŒ1ã¤ä»¥ä¸‹) ã‹ã¤ Hã‚’æŒã¤
                const chainNeighbors = neighbors.filter(n => mainChainPath.includes(n.idx));
                if (chainNeighbors.length <= 1 && neighbors.some(n => detectedAtoms[n.idx].isHydrogen)) {
                       candidates.push({ group: FUNCTIONAL_GROUPS.find(g => g.type === "ALDEHYDE"), atomIndex: cIndex });
                       return;
                }
                // ã‚±ãƒˆãƒ³
                candidates.push({ group: FUNCTIONAL_GROUPS.find(g => g.type === "KETONE"), atomIndex: cIndex });
                return;
            }

            // ã‚¢ãƒ«ã‚³ãƒ¼ãƒ« (-OH)
            // ä¸»é–Cã«å˜çµåˆOãŒã‚ã‚Šã€ãã®Oã«HãŒã¤ã„ã¦ã„ã‚‹
            const singleOH = neighbors.find(n => {
                if (detectedAtoms[n.idx].isOxygen && n.order === 1) {
                    const oNeighbors = getNeighbors(n.idx);
                    return oNeighbors.some(on => detectedAtoms[on.idx].isHydrogen);
                }
                return false;
            });
            if (singleOH) {
                candidates.push({ group: FUNCTIONAL_GROUPS.find(g => g.type === "ALCOHOL"), atomIndex: cIndex });
            }
        });

        // å¤šé‡çµåˆ (ã‚¢ãƒ«ã‚±ãƒ³/ã‚¢ãƒ«ã‚­ãƒ³)
        // ä¸»é–å†…ã®çµåˆã‚’ãƒã‚§ãƒƒã‚¯
        for (let i = 0; i < mainChainPath.length - 1; i++) {
            const u = mainChainPath[i];
            const v = mainChainPath[i+1];
            const bond = bonds.find(b => (b.atom1 === u && b.atom2 === v) || (b.atom2 === u && b.atom1 === v));
            if (bond) {
                if (bond.order === 3) candidates.push({ group: FUNCTIONAL_GROUPS.find(g => g.type === "ALKYNE"), atomIndex: u, atomIndex2: v }); // ä½ç½®ã¯å°ã•ã„ç•ªå·ã®C
                else if (bond.order === 2) candidates.push({ group: FUNCTIONAL_GROUPS.find(g => g.type === "ALKENE"), atomIndex: u, atomIndex2: v });
            }
        }

        if (candidates.length === 0) return { group: FUNCTIONAL_GROUPS.find(g => g.type === "ALKANE"), locants: [] };
        
        // å„ªå…ˆé †ä½ã§ã‚½ãƒ¼ãƒˆ
        candidates.sort((a, b) => a.group.priority - b.group.priority);
        const bestGroup = candidates[0].group;
        // åŒã˜å„ªå…ˆé †ä½ã®å®˜èƒ½åŸºãŒè¤‡æ•°ã‚ã‚‹å ´åˆã®ãŸã‚ã«ãƒªã‚¹ãƒˆåŒ–
        const principals = candidates.filter(c => c.group.type === bestGroup.type);
        
        return { group: bestGroup, occurrences: principals };
    }

    // â˜…â˜…â˜… 3. ç•ªå·ä»˜ã‘ã®æ–¹å‘æ±ºå®š â˜…â˜…â˜…
    function determineDirection(mainChainPath, principalInfo, substituents) {
        const len = mainChainPath.length;
        
        // ã‚¹ã‚³ã‚¢è¨ˆç®—é–¢æ•°: å°ã•ã„é…åˆ—ã®æ–¹ãŒã€Œå°ã•ã„ã€ã¨åˆ¤æ–­
        const compareArrays = (arr1, arr2) => {
            for (let i = 0; i < Math.min(arr1.length, arr2.length); i++) {
                if (arr1[i] < arr2[i]) return -1; // arr1ãŒå°ã•ã„
                if (arr1[i] > arr2[i]) return 1;  // arr2ãŒå°ã•ã„
            }
            if (arr1.length < arr2.length) return -1;
            if (arr1.length > arr2.length) return 1;
            return 0;
        };

        // ãƒ­ã‚«ãƒ³ãƒˆï¼ˆä½ç½®ç•ªå·ï¼‰ã®ãƒªã‚¹ãƒˆã‚’å–å¾— (1-based)
        const getLocants = (path) => {
            const mapIndexToLocant = {};
            path.forEach((atomIdx, i) => mapIndexToLocant[atomIdx] = i + 1);

            // 1. ä¸»è¦å®˜èƒ½åŸºã®ä½ç½®
            const pLocants = principalInfo.occurrences ? principalInfo.occurrences.map(o => mapIndexToLocant[o.atomIndex]).sort((a,b)=>a-b) : [];
            
            // 2. ç½®æ›åŸºã®ä½ç½®
            const sLocants = substituents.map(s => mapIndexToLocant[s.rootAtomIndex]).sort((a,b)=>a-b);

            return { p: pLocants, s: sLocants };
        };

        const forwardLocants = getLocants(mainChainPath);
        const backwardLocants = getLocants([...mainChainPath].reverse());

        // ãƒ«ãƒ¼ãƒ«1: ä¸»è¦å®˜èƒ½åŸºãŒå°ã•ã„æ–¹
        if (principalInfo.group.type !== "ALKANE") {
            const cmp = compareArrays(forwardLocants.p, backwardLocants.p);
            if (cmp < 0) return mainChainPath;
            if (cmp > 0) return [...mainChainPath].reverse();
        }

        // ãƒ«ãƒ¼ãƒ«2: ç½®æ›åŸºãŒå°ã•ã„æ–¹ (å¤šé‡çµåˆã¯ä¸»è¦å®˜èƒ½åŸºã«å«ã¾ã‚Œã‚‹ãŸã‚ã“ã“ã§å‡¦ç†æ¸ˆã¿)
        const cmpS = compareArrays(forwardLocants.s, backwardLocants.s);
        if (cmpS < 0) return mainChainPath;
        if (cmpS > 0) return [...mainChainPath].reverse();

        return mainChainPath; // ã©ã¡ã‚‰ã§ã‚‚åŒã˜
    }

// â˜…â˜…â˜… 4. ç½®æ›åŸºã®ç‰¹å®š (ã‚¨ãƒ¼ãƒ†ãƒ«å‘½åè¦å‰‡ã‚’åæ˜ ) â˜…â˜…â˜…
    function identifySubstituents(detectedAtoms, bonds, mainChainPath) {
        let subs = [];
        let visitedOxygens = new Set();
        
        const getNeighbors = (idx) => {
            const n = [];
            bonds.forEach(b => {
                if (b.atom1 === idx) n.push(b.atom2);
                else if (b.atom2 === idx) n.push(b.atom1);
            });
            return n;
        };

        // CåŸå­ãŒä¸»é–ä¸Šã®CåŸå­ã¨ç¹‹ãŒã£ã¦ã„ã‚‹ã‹ç¢ºèª
        const isConnectedToMainChain = (cIndex) => {
             const neighbors = getNeighbors(cIndex);
             return neighbors.some(nIdx => mainChainPath.includes(nIdx));
        };
        
        // Cé–ã®ç‚­ç´ æ•°ã‚’ã‚«ã‚¦ãƒ³ãƒˆ (DFS)
        function countCarbonChain(startIdx, stopIdx) {
            let count = 0;
            let visited = new Set([stopIdx]); // é€£çµç‚¹ã¾ãŸã¯æ¢ç´¢çµ‚äº†ç‚¹
            function countC(idx) {
                count++;
                visited.add(idx);
                getNeighbors(idx).forEach(next => {
                    // Cã®ã¿ã‚’è¾¿ã‚Šã€æ—¢ã«è¨ªå•ã—ãŸåŸå­ã‚„åœæ­¢ç‚¹ã‚’ç„¡è¦–
                    if (detectedAtoms[next].isCarbon && !visited.has(next)) countC(next);
                });
            }
            countC(startIdx);
            return count;
        }


        detectedAtoms.forEach((atom, idx) => {
            if (atom.isOxygen && !visitedOxygens.has(idx)) {
                const neighbors = getNeighbors(idx);
                const carbonNeighbors = neighbors.filter(n => detectedAtoms[n].isCarbon && n !== idx);
                
                // ã‚¨ãƒ¼ãƒ†ãƒ«æ§‹é€  C-O-C ã®æ¤œå‡º
                if (carbonNeighbors.length === 2 && atom.valenceUsed === 2) {
                    const cA = carbonNeighbors[0];
                    const cB = carbonNeighbors[1];
                    
                    // CåŸå­æ•°ã‚’ã‚«ã‚¦ãƒ³ãƒˆ (C-CçµåˆãŒã‚ã‚‹å ´åˆã€ãã®Cé–ã®é•·ã•å…¨ä½“ã‚’ã‚«ã‚¦ãƒ³ãƒˆ)
                    const countA = countCarbonChain(cA, idx);
                    const countB = countCarbonChain(cB, idx);

                    // ä¸»é–ã«å«ã¾ã‚Œã‚‹ã‹ã©ã†ã‹ã§åˆ¤æ–­
                    const cA_on_Main = mainChainPath.includes(cA);
                    const cB_on_Main = mainChainPath.includes(cB);

                    let mainSideC = -1;
                    let subSideC = -1;
                    let rootCIndex = -1;
                    
                    if (cA_on_Main && !cB_on_Main) { // AãŒä¸»é–ã€BãŒå´é–
                        mainSideC = cA;
                        subSideC = cB;
                        rootCIndex = cA;
                    } else if (!cA_on_Main && cB_on_Main) { // BãŒä¸»é–ã€AãŒå´é–
                        mainSideC = cB;
                        subSideC = cA;
                        rootCIndex = cB;
                    } else if (!cA_on_Main && !cB_on_Main) { // ä¸¡æ–¹å´é–ã®å ´åˆ (ã‚¨ãƒ¼ãƒ†ãƒ«ãŒä¸»é–ã«ã¶ã‚‰ä¸‹ãŒã£ã¦ã„ãªã„å ´åˆ)
                        // Cæ•°ã®å¤šã„æ–¹ãŒä¸»é–å´ã€å°‘ãªã„æ–¹ãŒå´é–å´ã«ãªã‚‹ã¹ãã ãŒã€
                        // ã“ã“ã§ã¯ä¸»é– (C-Cé–) ã«ã¯ç¹‹ãŒã£ã¦ã„ãªã„ãŒã€C-O-Cã¯å­˜åœ¨ã™ã‚‹å ´åˆã¨ã—ã¦ã€
                        // Cæ•°ã®å°‘ãªã„æ–¹ã‚’ã‚¢ãƒ«ã‚³ã‚­ã‚·åŸºã¨ã—ã¦æ‰±ã† (IUPACãƒ«ãƒ¼ãƒ«: ç‚­ç´ æ•°ã®å¤šã„æ–¹ã‚’è¦ªã‚¢ãƒ«ã‚«ãƒ³ã¨ã™ã‚‹)
                        if (countA >= countB) { // Bã‚’å´é–ã¨ã™ã‚‹
                            mainSideC = cA; 
                            subSideC = cB;
                            // ã©ã¡ã‚‰ã‚‚ä¸»é–ã«ç¹‹ãŒã£ã¦ãªã„ã®ã§ã€æœ€ã‚‚è¿‘ã„ä¸»é–Cã‚’æ ¹å…ƒã¨ã™ã‚‹ã®ãŒé›£ã—ã„ã€‚
                            // ä¾¿å®œä¸Šã€Cæ•°ã®å¤šã„å´ã‚’ã‚¢ãƒ«ã‚«ãƒ³ä¸»é–ã¨ã—ã¦æ‰±ã†ã€‚
                            rootCIndex = mainChainPath[0]; // æš«å®šçš„ã«ä¸»é–ã®æ ¹å…ƒã«ä½ç½®ä»˜ã‘
                        } else { // Aã‚’å´é–ã¨ã™ã‚‹
                            mainSideC = cB;
                            subSideC = cA;
                            rootCIndex = mainChainPath[0];
                        }
                    } else {
                        // ä¸¡æ–¹ä¸»é–ä¸Šã®å ´åˆ (ç’°çŠ¶/è¤‡é›‘) ã¯å‡¦ç†ã—ãªã„
                        return;
                    }
                    
                    if (subSideC !== -1) {
                        const subCount = (subSideC === cA) ? countA : countB;
                        
                        // Cæ•°ã«åŸºã¥ãã‚¢ãƒ«ã‚³ã‚­ã‚·å
                        let baseName = ALKYL_NAMES[subCount] || "ã‚¢ãƒ«ã‚­ãƒ«";
                        let oxyName = baseName.replace("ã‚¤ãƒ«", "ã‚ªã‚­ã‚·"); 
                        if (subCount === 1) oxyName = "ãƒ¡ãƒˆã‚­ã‚·"; 
                        if (subCount === 2) oxyName = "ã‚¨ãƒˆã‚­ã‚·";
                        
                        subs.push({ name: oxyName, rootAtomIndex: rootCIndex, type: 'ALKOXY' });
                        visitedOxygens.add(idx); // OåŸå­ã‚’ä½¿ç”¨æ¸ˆã¿ã¨ã—ã¦ãƒãƒ¼ã‚¯
                    }
                }
            }
        });


        // 5. Cå´é–ï¼ˆã‚¢ãƒ«ã‚­ãƒ«åŸºï¼‰ã®åˆ¤å®š (ã‚¨ãƒ¼ãƒ†ãƒ«ã«ä½¿ç”¨ã•ã‚Œãªã‹ã£ãŸCé–ã®ã¿)
        mainChainPath.forEach(rootIdx => {
            const neighbors = getNeighbors(rootIdx);
            neighbors.forEach(nIdx => {
                if (!mainChainPath.includes(nIdx) && detectedAtoms[nIdx].isCarbon) {
                    // æ—¢ã«ã‚¨ãƒ¼ãƒ†ãƒ«ã¨ã—ã¦ã‚«ã‚¦ãƒ³ãƒˆã•ã‚ŒãŸCé–ã‚’é¿ã‘ã‚‹ãƒ­ã‚¸ãƒƒã‚¯ã¯è¤‡é›‘ãªãŸã‚ã€
                    // ã“ã“ã§ã¯å˜ã«ä¸»é–ã«ãªã„Cé–ã‚’ã‚¢ãƒ«ã‚­ãƒ«åŸºã¨ã—ã¦ã‚«ã‚¦ãƒ³ãƒˆã™ã‚‹ï¼ˆé‡è¤‡ã®å¯èƒ½æ€§ã‚ã‚Šï¼‰
                    
                    let count = 0;
                    let visited = new Set([rootIdx]); 
                    function countC(idx) {
                        count++;
                        visited.add(idx);
                        getNeighbors(idx).forEach(next => {
                            if (detectedAtoms[next].isCarbon && !visited.has(next) && !mainChainPath.includes(next)) {
                                countC(next);
                            }
                        });
                    }
                    countC(nIdx);
                    
                    if (count > 0 && count < ALKYL_NAMES.length) {
                        subs.push({ name: ALKYL_NAMES[count], rootAtomIndex: rootIdx, type: 'ALKYL' });
                    }
                }
            });
        });
        
        return subs;
    }

    AFRAME.registerComponent('bond-analyzer', {
      init: function () {
        this.debugDiv = document.querySelector('#debug-div');
        this.analysisDiv = document.querySelector('#analysis-div'); 
        this.bondGroup = document.querySelector('#bond-group'); 
      },

      tick: function () {
        if (!this.debugDiv || !this.analysisDiv || !this.bondGroup) return; 

        while (this.bondGroup.firstChild) this.bondGroup.removeChild(this.bondGroup.firstChild);
        
        let localDetectedAtoms = [];
        let detectedBonds = [];
        let allMarkers = document.querySelectorAll('a-marker');
        
        allMarkers.forEach(marker => {
          if (!marker.object3D.visible) return; 
          let atomType = getAtomType(marker.id); 
          let markerData = { id: marker.id, type: atomType, pos: marker.object3D.position, valenceUsed: 0, atomIndex: -1, isHydrogen: atomType === 'H', isOxygen: atomType === 'O', isCarbon: atomType === 'C', markerEl: marker };
          if (atomType === 'C' || atomType === 'H' || atomType === 'O') localDetectedAtoms.push(markerData);
          else if (atomType === 'double-bond' || atomType === 'triple-bond') { markerData.used = false; detectedBonds.push(markerData); }
        });
        
        let detectedAtoms = localDetectedAtoms;
        MOLECULE_GRAPH.atoms = []; MOLECULE_GRAPH.bonds = [];
        let isStable = true;
        let output = "--- æ§‹é€ è§£æ ---\n";
        detectedAtoms.forEach((atom, index) => { atom.atomIndex = index; MOLECULE_GRAPH.atoms.push(atom.type); });
        
        // --- çµåˆåˆ¤å®šãƒ­ã‚¸ãƒƒã‚¯ ---
        // 1. O-C (C=O)
        for (let i = 0; i < detectedAtoms.length; i++) {
            let atomO = detectedAtoms[i]; if (!atomO.isOxygen) continue;
            for (let j = 0; j < detectedAtoms.length; j++) {
                let atomC = detectedAtoms[j]; if (i === j || !atomC.isCarbon) continue;
                if (Math.sqrt(Math.pow(atomO.pos.x - atomC.pos.x, 2) + Math.pow(atomO.pos.y - atomC.pos.y, 2)) < ATOM_BOND_THRESHOLD) {
                    let bondValue = 1; let markerUsed = null;
                    for (let bondMarker of detectedBonds) {
                        if (bondMarker.used) continue;
                        let distA = Math.sqrt(Math.pow(atomO.pos.x - bondMarker.pos.x, 2) + Math.pow(atomO.pos.y - bondMarker.pos.y, 2));
                        let distB = Math.sqrt(Math.pow(atomC.pos.x - bondMarker.pos.x, 2) + Math.pow(atomC.pos.y - bondMarker.pos.y, 2));
                        if (distA < MULTIPLE_BOND_ATOM_THRESHOLD && distB < MULTIPLE_BOND_ATOM_THRESHOLD) {
                            const localA = toMarkerLocalCoords(bondMarker.markerEl, atomO.pos);
                            const localB = toMarkerLocalCoords(bondMarker.markerEl, atomC.pos);
                            const isLateral = (localA.x * localB.x < 0) && (Math.abs(localA.y) < LATERAL_DISTANCE_THRESHOLD) && (Math.abs(localB.y) < LATERAL_DISTANCE_THRESHOLD);
                            if (isLateral && bondMarker.type === 'double-bond') { bondValue = 2; markerUsed = bondMarker; break; }
                        }
                    }
                    if (bondValue === 2) {
                        let existing = MOLECULE_GRAPH.bonds.findIndex(b => (b.atom1 === i && b.atom2 === j) || (b.atom2 === i && b.atom1 === j));
                        if (existing !== -1) { let b = MOLECULE_GRAPH.bonds[existing]; atomO.valenceUsed-=b.order; atomC.valenceUsed-=b.order; MOLECULE_GRAPH.bonds.splice(existing, 1); }
                        if (registerBond(atomO, atomC, 2)) markerUsed.used = true; 
                    }
                }
            }
        }
        // 2. C-C å¤šé‡
        for (let i = 0; i < detectedAtoms.length; i++) {
            let atomA = detectedAtoms[i]; if (!atomA.isCarbon) continue;
            for (let j = i + 1; j < detectedAtoms.length; j++) {
                let atomB = detectedAtoms[j]; if (!atomB.isCarbon) continue;
                if (MOLECULE_GRAPH.bonds.some(b => (b.atom1 === i && b.atom2 === j) || (b.atom2 === i && b.atom1 === j))) continue;
                if (Math.sqrt(Math.pow(atomA.pos.x - atomB.pos.x, 2) + Math.pow(atomA.pos.y - atomB.pos.y, 2)) < ATOM_BOND_THRESHOLD) {
                    let bondValue = 1; let markerUsed = null;
                    for (let bondMarker of detectedBonds) {
                        if (bondMarker.used) continue;
                        let distA = Math.sqrt(Math.pow(atomA.pos.x - bondMarker.pos.x, 2) + Math.pow(atomA.pos.y - bondMarker.pos.y, 2));
                        let distB = Math.sqrt(Math.pow(atomB.pos.x - bondMarker.pos.x, 2) + Math.pow(atomB.pos.y - bondMarker.pos.y, 2));
                        if (distA < MULTIPLE_BOND_ATOM_THRESHOLD && distB < MULTIPLE_BOND_ATOM_THRESHOLD) {
                            const localA = toMarkerLocalCoords(bondMarker.markerEl, atomA.pos);
                            const localB = toMarkerLocalCoords(bondMarker.markerEl, atomB.pos);
                            const isLateral = (localA.x * localB.x < 0) && (Math.abs(localA.y) < LATERAL_DISTANCE_THRESHOLD) && (Math.abs(localB.y) < LATERAL_DISTANCE_THRESHOLD);
                            if (isLateral) { 
                                if (bondMarker.type === 'triple-bond') { bondValue = 3; markerUsed = bondMarker; break; }
                                if (bondMarker.type === 'double-bond') { bondValue = 2; markerUsed = bondMarker; break; } 
                            }
                        }
                    }
                    if (bondValue > 1) { if (registerBond(atomA, atomB, bondValue)) markerUsed.used = true; }
                }
            }
        }
        // 3. Hçµåˆ
        const rightH = ['hydrogen-1', 'hydrogen-2', 'hydrogen-3'];
        const downH = ['hydrogen-4', 'hydrogen-5', 'hydrogen-6', 'hydrogen-7'];
        for (let i = 0; i < detectedAtoms.length; i++) {
            let atomA = detectedAtoms[i];
            if (atomA.isHydrogen) {
                let closest = null; let minD = ATOM_BOND_THRESHOLD;
                const isR = rightH.includes(atomA.id); const isD = downH.includes(atomA.id);
                for (let j = 0; j < detectedAtoms.length; j++) {
                    let atomB = detectedAtoms[j]; if (i === j || atomB.isHydrogen) continue;
                    if (MOLECULE_GRAPH.bonds.some(b => (b.atom1 === i && b.atom2 === j) || (b.atom2 === i && b.atom1 === j))) continue;
                    let d = Math.sqrt(Math.pow(atomA.pos.x - atomB.pos.x, 2) + Math.pow(atomA.pos.y - atomB.pos.y, 2));
                    if (d < minD) {
                        if (atomB.valenceUsed < getValence(atomB.type)) {
                            const local = toMarkerLocalCoords(atomA.markerEl, atomB.pos);
                            let valid = true;
                            if (isR) { if (!(local.x > 0 && Math.abs(local.y) < H_DIRECTION_TOLERANCE)) valid = false; }
                            else if (isD) { if (!(local.y < 0 && Math.abs(local.x) < H_DIRECTION_TOLERANCE)) valid = false; }
                            if (valid) { minD = d; closest = atomB; }
                        }
                    }
                }
                if (closest) registerBond(atomA, closest, 1);
            }
        }
        // 4. Oçµåˆ
        const oIndices = detectedAtoms.map((a, i) => a.isOxygen ? i : -1).filter(i => i !== -1);
        for (const i of oIndices) {
            let atomO = detectedAtoms[i];
            if (atomO.valenceUsed >= 2) continue;
            let neighbors = [];
            for (let j = 0; j < detectedAtoms.length; j++) {
                let atomX = detectedAtoms[j]; if (i === j || atomX.isHydrogen) continue;
                let currentBond = MOLECULE_GRAPH.bonds.filter(b => (b.atom1 === i && b.atom2 === j) || (b.atom2 === i && b.atom1 === j)).reduce((s, b) => s + b.order, 0);
                if (currentBond < getValence(atomO.type) && currentBond < getValence(atomX.type)) {
                    let d = Math.sqrt(Math.pow(atomO.pos.x - atomX.pos.x, 2) + Math.pow(atomO.pos.y - atomX.pos.y, 2));
                    if (d < ATOM_BOND_THRESHOLD) neighbors.push({ atom: atomX, dist: d });
                }
            }
            neighbors.sort((a, b) => a.dist - b.dist);
            const hCount = MOLECULE_GRAPH.bonds.filter(b => ((b.atom1 === i && detectedAtoms[b.atom2].isHydrogen) || (b.atom2 === i && detectedAtoms[b.atom1].isHydrogen))).length;
            let tryCount = 2 - atomO.valenceUsed; if (hCount >= 1) tryCount = 1;
            let done = 0;
            for (const n of neighbors) {
                if (done >= tryCount) break;
                let should = (hCount >= 1) || (atomO.valenceUsed < 2);
                if (should && registerBond(atomO, n.atom, 1)) done++;
            }
        }
        // 5. Cå˜çµåˆ
        for (let i = 0; i < detectedAtoms.length; i++) {
            let atomA = detectedAtoms[i]; if (!atomA.isCarbon) continue;
            for (let j = i + 1; j < detectedAtoms.length; j++) {
                let atomB = detectedAtoms[j]; if (atomB.isHydrogen) continue;
                if (MOLECULE_GRAPH.bonds.some(b => (b.atom1 === i && b.atom2 === j) || (b.atom2 === i && b.atom1 === j))) continue;
                let d = Math.sqrt(Math.pow(atomA.pos.x - atomB.pos.x, 2) + Math.pow(atomA.pos.y - atomB.pos.y, 2));
                if (d < ATOM_BOND_THRESHOLD) {
                    if (atomA.valenceUsed < 4 && atomB.valenceUsed < getValence(atomB.type)) registerBond(atomA, atomB, 1);
                }
            }
        }

        // æç”»
        MOLECULE_GRAPH.bonds.forEach(b => {
            const posA = b.atomAEl.object3D.position; const posB = b.atomBEl.object3D.position;
            const color = b.order === 1 ? '#FFFFFF' : (b.order === 2 ? '#FFD700' : '#4169E1');
            if (b.order === 1) this.bondGroup.appendChild(createBondCylinder(posA, posB, BOND_RADIUS, color, 0, 1));
            else if (b.order > 1) {
                this.bondGroup.appendChild(createBondCylinder(posA, posB, BOND_RADIUS, color, MULTIPLE_BOND_OFFSET, 1));
                this.bondGroup.appendChild(createBondCylinder(posA, posB, BOND_RADIUS, color, -MULTIPLE_BOND_OFFSET, 1));
                if (b.order === 3) this.bondGroup.appendChild(createBondCylinder(posA, posB, BOND_RADIUS, color, 0, 1));
            }
        });
        
        for (let i = 0; i < detectedAtoms.length; i++) {
            let a = detectedAtoms[i];
            let t = a.markerEl.querySelector('a-text');
            if(t) t.setAttribute('value', `${a.type}${i+1} (${a.valenceUsed}/${getValence(a.type)})`);
            if (a.valenceUsed > getValence(a.type)) { isStable = false; output += `è­¦å‘Š: ${a.id} æ‰‹ãŒå¤šã„\n`; }
            else if (a.valenceUsed < getValence(a.type) && detectedAtoms.length > 1) { if (a.isCarbon||a.isOxygen) { isStable = false; output += `è­¦å‘Š: ${a.id} æ‰‹ãŒå°‘ãªã„\n`; } }
        }
        if (isStable && detectedAtoms.length>0) { output += "âœ… å®‰å®š"; this.debugDiv.style.color = '#00FF00'; }
        else { this.debugDiv.style.color = '#FF0000'; output += "âŒ ä¸å®‰å®š"; }
        this.debugDiv.innerText = output;

        // ============================================================
        // â˜…â˜…â˜… IUPACå‘½åç”Ÿæˆãƒ­ã‚¸ãƒƒã‚¯ (çµ±åˆ) â˜…â˜…â˜…
        // ============================================================
        
        // 1. æœ€é•·ç‚­ç´ é–ãƒ‘ã‚¹ã®å–å¾—
        const mainPath = findLongestChainPath(detectedAtoms, MOLECULE_GRAPH);
        const mainLen = mainPath.length;
        
        if (mainLen > 0) {
            // 2. ä¸»è¦å®˜èƒ½åŸºã®ç‰¹å®š
            const pInfo = identifyPrincipalGroup(detectedAtoms, MOLECULE_GRAPH.bonds, mainPath);
            
            // 3. ç½®æ›åŸºå€™è£œã®æ¤œå‡º (ä¸»é–ã‹ã‚‰ã¶ã‚‰ä¸‹ãŒã£ã¦ã„ã‚‹ã‚‚ã®)
            const rawSubs = identifySubstituents(detectedAtoms, MOLECULE_GRAPH.bonds, mainPath);
            
            // 4. ç•ªå·ä»˜ã‘ (æ–¹å‘æ±ºå®š)
            const orderedPath = determineDirection(mainPath, pInfo, rawSubs);
            
            // ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ -> ãƒ­ã‚«ãƒ³ãƒˆ(1,2,3...) ã®ãƒãƒƒãƒ—ä½œæˆ
            const locantMap = {};
            orderedPath.forEach((idx, i) => locantMap[idx] = i + 1);
            
            // 5. åç§°æ§‹ç¯‰
            
            // æ¥é ­è¾ (Prefix) éƒ¨åˆ†: ç½®æ›åŸº
            let prefixParts = [];
            let subGroups = {}; // åå‰ã”ã¨ã«ã¾ã¨ã‚ã‚‹
            rawSubs.forEach(s => {
                if (!subGroups[s.name]) subGroups[s.name] = [];
                subGroups[s.name].push(locantMap[s.rootAtomIndex]);
            });
            
            // ç½®æ›åŸºã‚’ã‚½ãƒ¼ãƒˆã—ã¦æ–‡å­—åˆ—åŒ– (ä¾‹: 2,3-ã‚¸ãƒ¡ãƒãƒ«)
            Object.keys(subGroups).sort().forEach(name => {
                const locs = subGroups[name].sort((a,b)=>a-b);
                const numPrefix = NUMERAL_PREFIXES[locs.length] || "";
                prefixParts.push(`${locs.join(',')}-${numPrefix}${name}`);
            });
            const prefixStr = prefixParts.join(''); // ã‚¢ãƒ«ãƒ•ã‚¡ãƒ™ãƒƒãƒˆé †ã‚½ãƒ¼ãƒˆã¯ä»Šå›ã¯çœç•¥(ã‚­ãƒ¼é †)

            // ä¸»é–å (Parent)
            let parentName = (mainLen < ALKANE_NAMES.length) ? ALKANE_NAMES[mainLen] : `C${mainLen}`;
            
            // ã‚¢ãƒ«ã‚±ãƒ³ãƒ»ã‚¢ãƒ«ã‚­ãƒ³ã®å‡¦ç† (èªå°¾å¤‰åŒ–: ã‚¢ãƒ³ -> ã‚¨ãƒ³/ã‚¤ãƒ³)
            // å¤šé‡çµåˆã®ä½ç½®ã‚’æ¢ã™
            let doubleBondLocants = [];
            let tripleBondLocants = [];
            for(let k=0; k<orderedPath.length-1; k++) {
                let u = orderedPath[k], v = orderedPath[k+1];
                let bond = MOLECULE_GRAPH.bonds.find(b => (b.atom1===u && b.atom2===v) || (b.atom2===u && b.atom1===v));
                if(bond && bond.order === 2) doubleBondLocants.push(k+1);
                if(bond && bond.order === 3) tripleBondLocants.push(k+1);
            }
            
            let enYneSuffix = "";
            if (doubleBondLocants.length > 0) {
                parentName = parentName.replace("ãƒ³", ""); // ãƒ—ãƒ­ãƒ‘ãƒ³ -> ãƒ—ãƒ­ãƒ‘
                let locStr = doubleBondLocants.join(',');
                let numPre = NUMERAL_PREFIXES[doubleBondLocants.length] || "";
                enYneSuffix += `-${locStr}-${numPre}ã‚¨ãƒ³`;
            }
            if (tripleBondLocants.length > 0) {
                if (doubleBondLocants.length === 0) parentName = parentName.replace("ãƒ³", "");
                let locStr = tripleBondLocants.join(',');
                let numPre = NUMERAL_PREFIXES[tripleBondLocants.length] || "";
                enYneSuffix += `-${locStr}-${numPre}ã‚¤ãƒ³`;
            }

            // æ¥å°¾è¾ (Suffix)
            let suffixStr = "";
            if (pInfo.group.type !== "ALKANE" && pInfo.group.type !== "ALKENE" && pInfo.group.type !== "ALKYNE" && pInfo.group.type !== "ETHER") {
                // ã‚¢ãƒ«ã‚³ãƒ¼ãƒ«ã€ã‚±ãƒˆãƒ³ã€ã‚¢ãƒ«ãƒ‡ãƒ’ãƒ‰ã€ã‚«ãƒ«ãƒœãƒ³é…¸
                // ä½ç½®ç•ªå·ãŒå¿…è¦ãªã‚‚ã® (ã‚¢ãƒ«ãƒ‡ãƒ’ãƒ‰ã€ã‚«ãƒ«ãƒœãƒ³é…¸ã¯é€šå¸¸1ç•ªãªã®ã§çœç•¥ã•ã‚Œã‚‹ã“ã¨ãŒå¤šã„ãŒã€ã‚±ãƒˆãƒ³ãƒ»ã‚¢ãƒ«ã‚³ãƒ¼ãƒ«ã¯å¿…è¦)
                let pLocs = pInfo.occurrences.map(o => locantMap[o.atomIndex]).sort((a,b)=>a-b);
                // ã‚¢ãƒ«ãƒ‡ãƒ’ãƒ‰ãƒ»ã‚«ãƒ«ãƒœãƒ³é…¸ã¯ä¸¡ç«¯ãªã‚‰ä½ç½®çœç•¥å¯èƒ½ã ãŒã€ã“ã“ã§ã¯å˜ç´”çµåˆ
                let locStr = pLocs.join(',');
                let numPre = NUMERAL_PREFIXES[pLocs.length] || "";
                
                // æ¯ä½“åæœ«å°¾ã®ã€Œãƒ³ã€ã‚’ã¨ã‚‹ã‹ã©ã†ã‹ï¼ˆæ—¥æœ¬èªIUPACã§ã¯æ®‹ã™ã“ã¨ãŒå¤šã„: ãƒ—ãƒ­ãƒ‘ãƒ³ã‚ªãƒ³ -> ãƒ—ãƒ­ãƒ‘ãƒãƒ³ã€ãƒ–ã‚¿ãƒ³ã‚ªãƒ¼ãƒ« -> ãƒ–ã‚¿ãƒãƒ¼ãƒ«ï¼‰
                // ç°¡æ˜“å®Ÿè£…: ãã®ã¾ã¾çµåˆ
                suffixStr = `-${locStr}-${numPre}${pInfo.group.suffix}`;
                
                // ã‚¢ãƒ«ãƒ‡ãƒ’ãƒ‰ãƒ»ã‚«ãƒ«ãƒœãƒ³é…¸ã§ä½ç½®ãŒ1ãªã‚‰çœç•¥ã™ã‚‹æ…£ç¿’ã¸ã®ç°¡æ˜“å¯¾å¿œ
                if ((pInfo.group.type === "ALDEHYDE" || pInfo.group.type === "CARBOXYLIC") && pLocs.length === 1 && pLocs[0] === 1) {
                    suffixStr = pInfo.group.suffix; // ä½ç½®ç•ªå·å‰Šé™¤
                }
            }

            // æ–‡å­—åˆ—ã®æ•´å½¢ (å…ˆé ­ã®ãƒã‚¤ãƒ•ãƒ³å‰Šé™¤ãªã©)
            let finalName = `${prefixStr}${parentName}${enYneSuffix}${suffixStr}`;
            finalName = finalName.replace(/^-/, "").replace(/--/g, "-");

            // â˜…â˜…â˜… æ–°æ©Ÿèƒ½: æ…£ç”¨åã®æ¤œç´¢ã¨è¡¨ç¤º â˜…â˜…â˜…
            // â˜…â˜…â˜… ä¿®æ­£ç®‡æ‰€ 2: æ…£ç”¨åã¨å‚™è€ƒã®æ¤œç´¢ãƒ»è¡¨ç¤ºãƒ­ã‚¸ãƒƒã‚¯ â˜…â˜…â˜…
        const commonInfo = COMMON_NAMES[finalName];
        let commonNameDisplay = "";
        
        if (commonInfo) {
            commonNameDisplay = 
                `\n\næ…£ç”¨å: \n${commonInfo.name}` + 
                `\nå‚™è€ƒ: \n${commonInfo.note}`; // å‚™è€ƒæ¬„ã‚’è¿½åŠ 
        }

        // è¡¨ç¤º
        this.analysisDiv.innerText = `--- æ§‹é€ ã®åˆ†æ ---\n` +
            `ä¸»é–: C${mainLen} (${mainPath.join('-')})\n` +
            `ä¸»è¦å®˜èƒ½åŸº: ${pInfo.group.name}\n` +
            `IUPACå: \n${finalName}` +
            commonNameDisplay; // æ…£ç”¨åã¨å‚™è€ƒã‚’è¿½åŠ 
        } else {
            this.analysisDiv.innerText = "--- æ§‹é€ ã®åˆ†æ ---\nç‚­ç´ é–ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“";
        }
      }
    });
  </script>
    
  <head>
    <style>
      #debug-div { position: absolute; top: 10px; left: 10px; z-index: 999; color: white; font-family: monospace; font-size: 14px; background: rgba(0,0,0,0.5); padding: 5px; white-space: pre-wrap; }
      #analysis-div { position: absolute; top: 10px; right: 10px; z-index: 999; color: #00FFFF; font-family: monospace; font-size: 16px; background: rgba(0,0,0,0.5); padding: 10px; white-space: pre-wrap; text-align: right; font-weight: bold; }
    </style>
  </head>

  <body style="margin : 0px; overflow: hidden;">
    <div id="debug-div">ARçµåˆåˆ†æAI</div>
    <div id="analysis-div">è§£æä¸­...</div>
    <a-scene embedded arjs="detectionMode: mono_and_matrix; matrixCodeType: 3x3;" bond-analyzer>
      <a-entity id="bond-group"></a-entity>
      <a-marker id="carbon-1" type="pattern" url="carbon-1.patt"><a-text value="C1" color="red" rotation="-90 0 0"></a-text></a-marker>
      <a-marker id="carbon-2" type="pattern" url="carbon-2.patt"><a-text value="C2" color="red" rotation="-90 0 0"></a-text></a-marker>
      <a-marker id="carbon-3" type="pattern" url="carbon-3.patt"><a-text value="C3" color="red" rotation="-90 0 0"></a-text></a-marker>
      <a-marker id="carbon-4" type="pattern" url="carbon-4.patt"><a-text value="C4" color="red" rotation="-90 0 0"></a-text></a-marker>
      <a-marker id="carbon-5" type="pattern" url="carbon-5.patt"><a-text value="C5" color="red" rotation="-90 0 0"></a-text></a-marker>
      <a-marker id="carbon-6" type="pattern" url="carbon-6.patt"><a-text value="C6" color="red" rotation="-90 0 0"></a-text></a-marker>
      <a-marker id="carbon-7" type="pattern" url="carbon-7.patt"><a-text value="C7" color="red" rotation="-90 0 0"></a-text></a-marker>
      <a-marker id="hydrogen-1" type="pattern" url="hydrogen-1.patt"><a-text value="H" color="blue" rotation="-90 0 0"></a-text></a-marker>
      <a-marker id="hydrogen-2" type="pattern" url="hydrogen-2.patt"><a-text value="H" color="blue" rotation="-90 0 0"></a-text></a-marker>
      <a-marker id="hydrogen-3" type="pattern" url="hydrogen-3.patt"><a-text value="H" color="blue" rotation="-90 0 0"></a-text></a-marker>
      <a-marker id="hydrogen-4" type="pattern" url="hydrogen-4.patt"><a-text value="H" color="blue" rotation="-90 0 0"></a-text></a-marker>
      <a-marker id="hydrogen-5" type="pattern" url="hydrogen-5.patt"><a-text value="H" color="blue" rotation="-90 0 0"></a-text></a-marker>
      <a-marker id="hydrogen-6" type="pattern" url="hydrogen-6.patt"><a-text value="H" color="blue" rotation="-90 0 0"></a-text></a-marker>
      <a-marker id="hydrogen-7" type="pattern" url="hydrogen-7.patt"><a-text value="H" color="blue" rotation="-90 0 0"></a-text></a-marker>
      <a-marker id="oxygen-1" type="pattern" url="oxygen-1.patt"><a-text value="O" color="green" rotation="-90 0 0"></a-text></a-marker>
      <a-marker id="oxygen-2" type="pattern" url="oxygen-2.patt"><a-text value="O" color="green" rotation="-90 0 0"></a-text></a-marker>
      <a-marker id="double-bond" type="pattern" url="double.patt"><a-box color="yellow" scale="0.5 0.5 0.5"></a-box></a-marker>
      <a-marker id="triple-bond" type="pattern" url="triple.patt"><a-box color="cyan" scale="0.5 0.5 0.5"></a-box></a-marker>
      <a-entity camera></a-entity>
    </a-scene>
  </body>
</html>