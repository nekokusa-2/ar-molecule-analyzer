<!DOCTYPE html>
<html>
  <script src="https://aframe.io/releases/1.0.0/aframe.min.js"></script>
  <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar.js"></script>

  <script>
    // â˜… æ§‹é€ è§£æãƒ‡ãƒ¼ã‚¿
    let MOLECULE_GRAPH = { atoms: [], bonds: [] }; 

    // å®šæ•°å®šç¾©
    const ATOM_BOND_THRESHOLD = 3.0; 
    const MULTIPLE_BOND_ATOM_THRESHOLD = 3.0; 
    const LATERAL_DISTANCE_THRESHOLD = 1.0; 
    const H_DIRECTION_TOLERANCE = 1.0; 
    const BOND_RADIUS = 0.05; 
    const MULTIPLE_BOND_OFFSET = 0.08; 

    // å‘½åç”¨ãƒ‡ãƒ¼ã‚¿
    const ALKANE_NAMES = ["", "ãƒ¡ã‚¿ãƒ³", "ã‚¨ã‚¿ãƒ³", "ãƒ—ãƒ­ãƒ‘ãƒ³", "ãƒ–ã‚¿ãƒ³", "ãƒšãƒ³ã‚¿ãƒ³", "ãƒ˜ã‚­ã‚µãƒ³", "ãƒ˜ãƒ—ã‚¿ãƒ³", "ã‚ªã‚¯ã‚¿ãƒ³", "ãƒãƒŠãƒ³", "ãƒ‡ã‚«ãƒ³"];
    const ALKYL_NAMES = ["", "ãƒ¡ãƒãƒ«", "ã‚¨ãƒãƒ«", "ãƒ—ãƒ­ãƒ”ãƒ«", "ãƒ–ãƒãƒ«", "ãƒšãƒ³ãƒãƒ«", "ãƒ˜ã‚­ã‚·ãƒ«"]; // å´é–ç”¨
    const NUMERAL_PREFIXES = ["", "", "ã‚¸", "ãƒˆãƒª", "ãƒ†ãƒˆãƒ©", "ãƒšãƒ³ã‚¿", "ãƒ˜ã‚­ã‚µ"]; // å€æ•°æ¥é ­è¾

    // å®˜èƒ½åŸºå®šç¾©
    const FUNCTIONAL_GROUPS = [
        { name: "ã‚«ãƒ«ãƒœãƒ³é…¸", suffix: "é…¸", priority: 1, type: "CARBOXYLIC" },
        // ã‚¨ã‚¹ãƒ†ãƒ«ã‚’è¿½åŠ 
        { name: "ã‚¨ã‚¹ãƒ†ãƒ«", suffix: "é…¸", priority: 2, type: "ESTER" }, 
        { name: "ã‚¢ãƒ«ãƒ‡ãƒ’ãƒ‰", suffix: "ã‚¢ãƒ¼ãƒ«", priority: 3, type: "ALDEHYDE" },
        { name: "ã‚±ãƒˆãƒ³", suffix: "ã‚ªãƒ³", priority: 4, type: "KETONE" },
        { name: "ã‚¢ãƒ«ã‚³ãƒ¼ãƒ«", suffix: "ã‚ªãƒ¼ãƒ«", priority: 5, type: "ALCOHOL" },
        { name: "ã‚¢ãƒ«ã‚­ãƒ³", suffix: "ã‚¤ãƒ³", priority: 6, type: "ALKYNE" }, // ä¸»é–åã®ä¸€éƒ¨ã‚’å¤‰å½¢
        { name: "ã‚¢ãƒ«ã‚±ãƒ³", suffix: "ã‚¨ãƒ³", priority: 7, type: "ALKENE" }, // ä¸»é–åã®ä¸€éƒ¨ã‚’å¤‰å½¢
        { name: "ã‚¨ãƒ¼ãƒ†ãƒ«", suffix: "", priority: 8, type: "ETHER" }, // æ¥é ­è¾æ‰±ã„
        { name: "ã‚¢ãƒ«ã‚«ãƒ³", suffix: "ã‚¢ãƒ³", priority: 9, type: "ALKANE" }
    ];

    // â˜…â˜…â˜… æ–°æ©Ÿèƒ½: æ…£ç”¨åãƒ‡ãƒ¼ã‚¿ (æ‰‹å‹•è¿½åŠ ) â˜…â˜…â˜…
    // ã‚­ãƒ¼: ç”Ÿæˆã•ã‚ŒãŸIUPACå
    // å€¤: { name: æ…£ç”¨å, note: å‚™è€ƒ }
    const COMMON_NAMES = {
        "ãƒ¡ã‚¿ãƒ³é…¸": { 
            name: "ã‚®é…¸ (Formic Acid)", 
            note: "ğŸœ ãƒ©ãƒ†ãƒ³èªã§ã€Œã‚¢ãƒªã€ã‚’æ„å‘³ã™ã‚‹ Formica ãŒèªæºã€‚ã‚¢ãƒªãŒå¤–æ•µã‹ã‚‰èº«ã‚’å®ˆã‚‹ãŸã‚ã«åˆ†æ³Œã—ã¾ã™ã€‚" 
        },
        "ã‚¨ã‚¿ãƒ³é…¸": { 
            name: "é…¢é…¸ (Acetic Acid)", 
            note: "ãƒ©ãƒ†ãƒ³èªã§ã€Œé…¢ã€ã‚’æ„å‘³ã™ã‚‹ Acetum ãŒèªæºã€‚é…¢ã®ä¸»æˆåˆ†ã§ã‚ã‚Šã€é…¸å‘³ã®ã‚‚ã¨ã§ã™ã€‚" 
        },
        "ãƒ–ã‚¿ãƒ³é…¸": { 
            name: "é…ªé…¸ (Butyric Acid)", 
            note: "ğŸ§ˆ ãƒ©ãƒ†ãƒ³èªã§ã€Œãƒã‚¿ãƒ¼ã€ã‚’æ„å‘³ã™ã‚‹ Butyrum ãŒèªæºã€‚ãƒã‚¿ãƒ¼ã‚„ã€æ±—ã€éŠ€æã«å«ã¾ã‚Œã‚‹ä¸å¿«ãªè‡­ã„ã®åŸå› ç‰©è³ªã§ã™ã€‚" 
        },
        "ã‚¨ã‚¿ãƒ³-1-ã‚ªãƒ¼ãƒ«": { 
            name: "ã‚¨ãƒãƒ«ã‚¢ãƒ«ã‚³ãƒ¼ãƒ«ã€ã‚¨ã‚¿ãƒãƒ¼ãƒ« (Ethanol)", 
            note: "ğŸº é£²ç”¨ã•ã‚Œã‚‹ã‚¢ãƒ«ã‚³ãƒ¼ãƒ«ã€‚ç™ºé…µã«ã‚ˆã£ã¦ä½œã‚‰ã‚Œã¾ã™ã€‚" 
        },
        "ãƒ¡ã‚¿ãƒ³-1-ã‚ªãƒ¼ãƒ«": { 
            name: "ãƒ¡ãƒãƒ«ã‚¢ãƒ«ã‚³ãƒ¼ãƒ«ã€ãƒ¡ã‚¿ãƒãƒ¼ãƒ« (Methanol)", 
            note: "ğŸªµ ã‹ã¤ã¦æœ¨æã®ä¹¾ç•™ã«ã‚ˆã£ã¦è£½é€ ã•ã‚Œã¦ã„ãŸãŸã‚ã€Œæœ¨ç²¾ï¼ˆã‚‚ãã›ã„ï¼‰ã€ã¨ã‚‚å‘¼ã°ã‚Œã¾ã™ã€‚æ¯’æ€§ãŒéå¸¸ã«å¼·ã„ã§ã™ã€‚" 
        },
        "ã‚¨ã‚¿ãƒ³-1,2-ã‚¸ã‚ªãƒ¼ãƒ«": { 
            name: "ã‚¨ãƒãƒ¬ãƒ³ã‚°ãƒªã‚³ãƒ¼ãƒ« (Ethylene Glycol)", 
            note: "ğŸš— ä¸å‡æ¶²ã‚„ãƒãƒªã‚¨ãƒãƒ¬ãƒ³ãƒ†ãƒ¬ãƒ•ã‚¿ãƒ©ãƒ¼ãƒˆï¼ˆPETï¼‰ã®åŸæ–™ã€‚ç”˜ã¿ãŒã‚ã‚‹ãŸã‚èª¤é£²ã«æ³¨æ„ãŒå¿…è¦ã§ã™ï¼ˆäººä½“ã«ã¯æœ‰æ¯’ï¼‰ã€‚" 
        },
        "ãƒ—ãƒ­ãƒ‘ãƒ³-1,2,3-ãƒˆãƒªã‚ªãƒ¼ãƒ«": { 
            name: "ã‚°ãƒªã‚»ãƒªãƒ³ (Glycerin)", 
            note: "âœ¨ æ²¹è„‚ï¼ˆè„‚è‚ªï¼‰ã®ä¸»æˆåˆ†ã§ã‚ã‚Šã€ä¿æ¹¿å‰¤ã¨ã—ã¦åŒ–ç²§å“ã‚„åŒ»è–¬å“ã«åºƒãä½¿ã‚ã‚Œã¾ã™ã€‚ç”˜ã¿ãŒã‚ã‚Šã€ç„¡æ¯’ã§ã™ã€‚" 
        },
        "ãƒ—ãƒ­ãƒ‘ãƒ³-2-ã‚ªãƒ¼ãƒ«": { 
            name: "ã‚¤ã‚½ãƒ—ãƒ­ãƒ”ãƒ«ã‚¢ãƒ«ã‚³ãƒ¼ãƒ«ã€2-ãƒ—ãƒ­ãƒ‘ãƒãƒ¼ãƒ« (Isopropanol)", 
            note: "ğŸ§¼ æ¶ˆæ¯’æ¶²ã‚„æ´—æµ„æ¶²ã¨ã—ã¦å¹…åºƒãä½¿ã‚ã‚Œã¾ã™ã€‚ã‚±ãƒˆãƒ³ä½“ã®ã‚¢ã‚»ãƒˆãƒ³ã¨ç›¸äº’å¤‰æ›ã®é–¢ä¿‚ã«ã‚ã‚Šã¾ã™ã€‚" 
        },
        "ã‚¨ã‚¿-1-ã‚¨ãƒ³": { 
            name: "ã‚¨ãƒãƒ¬ãƒ³ (Ethylene)", 
            note: "ğŸŒ æ¤ç‰©ãƒ›ãƒ«ãƒ¢ãƒ³ã¨ã—ã¦åƒãã€æœç‰©ã®æˆç†Ÿï¼ˆè¿½ç†Ÿï¼‰ã‚’ä¿ƒé€²ã™ã‚‹ä½œç”¨ãŒã‚ã‚Šã¾ã™ã€‚æœ€ã‚‚ç°¡å˜ãªã‚¢ãƒ«ã‚±ãƒ³ã§ã™ã€‚" 
        },
        "ãƒ—ãƒ­ãƒ‘-1-ã‚¨ãƒ³": { 
            name: "ãƒ—ãƒ­ãƒ”ãƒ¬ãƒ³ (Propylene)", 
            note: "ğŸ­ 2ç•ªç›®ã«å˜ç´”ãªã‚¢ãƒ«ã‚±ãƒ³ã€‚ãƒãƒªãƒ—ãƒ­ãƒ”ãƒ¬ãƒ³ï¼ˆãƒ—ãƒ©ã‚¹ãƒãƒƒã‚¯ï¼‰ã‚’è£½é€ ã™ã‚‹ãŸã‚ã®ä¸»åŸæ–™ã§ã™ã€‚" 
        },
        "ã‚¨ã‚¿-1-ã‚¤ãƒ³": { 
            name: "ã‚¢ã‚»ãƒãƒ¬ãƒ³ (Acetylene)", 
            note: "ğŸ”¥ é…¸ç´ ã¨æ··ãœã‚‹ã¨ç´„3,300â„ƒã®é«˜æ¸©ãŒå¾—ã‚‰ã‚Œã‚‹ãŸã‚ã€ã‚¬ã‚¹æº¶æ¥ã‚„åˆ‡æ–­ã«æ¬ ã‹ã›ãªã„ç‡ƒæ–™ã‚¬ã‚¹ã¨ã—ã¦ä½¿ã‚ã‚Œã¾ã™ã€‚" 
        },
        "ã‚¨ã‚¿-1-ã‚¨ãƒ³-1-ã‚ªãƒ¼ãƒ«": { 
            name: "ã‚¨ãƒ†ãƒãƒ¼ãƒ«ã€ãƒ“ãƒ‹ãƒ«ã‚¢ãƒ«ã‚³ãƒ¼ãƒ« (Vinyl alcohol)", 
            note: "ğŸ§ª é‡åˆã™ã‚‹ã¨ãƒãƒªãƒ“ãƒ‹ãƒ«ã‚¢ãƒ«ã‚³ãƒ¼ãƒ«ï¼ˆæ´—æ¿¯ã®ã‚Šã€æ°´æº¶æ€§ãƒ•ã‚£ãƒ«ãƒ ãªã©ï¼‰ã«ãªã‚Šã¾ã™ã€‚éŠé›¢ã—ãŸçŠ¶æ…‹ã§ã¯ä¸å®‰å®šã§ã€é€šå¸¸ã¯ç•°æ€§ä½“ã®ã‚¢ã‚»ãƒˆã‚¢ãƒ«ãƒ‡ãƒ’ãƒ‰ã¨ã—ã¦å­˜åœ¨ã—ã¾ã™ã€‚" 
        },
        "ãƒ—ãƒ­ãƒ‘ãƒ³-2-ã‚ªãƒ³": { 
            name: "ã‚¢ã‚»ãƒˆãƒ³ (Acetone)", 
            note: "ğŸ’… æœ€ã‚‚ç°¡å˜ãªã‚±ãƒˆãƒ³ã€‚æ²¹ã‚’ã‚ˆãæº¶ã‹ã—ã€äººä½“ã¸ã®æ¯’æ€§ã‚‚ä½ã„ã“ã¨ã‹ã‚‰ã€é™¤å…‰æ¶²ã‚„æœ‰æ©Ÿæº¶åª’ã¨ã—ã¦å¤šç”¨ã•ã‚Œã¾ã™ã€‚" 
        },
        "ãƒ¡ã‚¿ãƒ³ã‚¢ãƒ¼ãƒ«": { 
            name: "ãƒ›ãƒ«ãƒ ã‚¢ãƒ«ãƒ‡ãƒ’ãƒ‰ (Formaldehyde)", 
            note: "ğŸ¦  37%æ°´æº¶æ¶²ãŒãƒ›ãƒ«ãƒãƒªãƒ³ã¨å‘¼ã°ã‚Œã€é˜²è…å‰¤ã‚„æ¶ˆæ¯’å‰¤ã¨ã—ã¦åˆ©ç”¨ã•ã‚Œã¾ã™ã€‚åˆºæ¿€è‡­ãŒã‚ã‚Šã¾ã™ã€‚" 
        },
        "ã‚¨ã‚¿ãƒ³ã‚¢ãƒ¼ãƒ«": { 
            name: "ã‚¢ã‚»ãƒˆã‚¢ãƒ«ãƒ‡ãƒ’ãƒ‰ (Formaldehyde)", 
            note: "ğŸ¤¢ ã‚¢ãƒ«ã‚³ãƒ¼ãƒ«ï¼ˆã‚¨ã‚¿ãƒãƒ¼ãƒ«ï¼‰ãŒä½“å†…ã§åˆ†è§£ã•ã‚Œã¦ã§ãã‚‹ä¸­é–“ç‰©è³ªã€‚äºŒæ—¥é…”ã„ã®åŸå› ç‰©è³ªã§ã™ã€‚å¼·ã„åˆºæ¿€è‡­ãŒã‚ã‚Šã¾ã™ã€‚" 
        },
        "1-ãƒ¡ãƒˆã‚­ã‚·ãƒ¡ã‚¿ãƒ³": { 
            name: "ã‚¸ãƒ¡ãƒãƒ«ã‚¨ãƒ¼ãƒ†ãƒ« (Dimethyl ether)", 
            note: "ğŸ’¨ æœ€ã‚‚ç°¡å˜ãªã‚¨ãƒ¼ãƒ†ãƒ«ã€‚è¿‘å¹´ã¯LPã‚¬ã‚¹ã®ä»£æ›¿ç‡ƒæ–™ã‚„ã‚¨ã‚¢ã‚¾ãƒ¼ãƒ«å™´å°„å‰¤ã¨ã—ã¦æ³¨ç›®ã•ã‚Œã¦ã„ã¾ã™ã€‚" 
        },
        "1-ã‚¨ãƒˆã‚­ã‚·ã‚¨ã‚¿ãƒ³": { 
            name: "ã‚¸ã‚¨ãƒãƒ«ã‚¨ãƒ¼ãƒ†ãƒ« (Diethyl ether)", 
            note: "ğŸ‘ƒ ç‰¹æœ‰ã®ç”˜ã„åŒ‚ã„ã‚’æŒã¤æ®ç™ºæ€§ã®æ¶²ä½“ã§ã™ã€‚ã‹ã¤ã¦ã¯å…¨èº«éº»é…”è–¬ã¨ã—ã¦åºƒãä½¿ã‚ã‚Œã¦ã„ã¾ã—ãŸã€‚" 
        },
        "ãƒ¡ã‚¿ãƒ³é…¸ãƒ¡ãƒãƒ«": { 
            name: "ã‚®é…¸ãƒ¡ãƒãƒ« (Methyl formate)", 
            note: "ğŸ‡ æœå®Ÿè‡­ã‚’æŒã¤ã‚¨ã‚¹ãƒ†ãƒ«ã€‚æœ‰æ©Ÿæº¶åª’ã¨ã—ã¦åˆ©ç”¨ã•ã‚Œã¾ã™ã€‚" 
        },
        "ã‚¨ã‚¿ãƒ³é…¸ã‚¨ãƒãƒ«": { 
            name: "é…¢é…¸ã‚¨ãƒãƒ« (Ethyl acetate)", 
            note: "ğŸ ãƒ‘ã‚¤ãƒŠãƒƒãƒ—ãƒ«ã®ã‚ˆã†ãªèŠ³é¦™ã‚’æŒã¤ä»£è¡¨çš„ãªã‚¨ã‚¹ãƒ†ãƒ«ã€‚æœ‰æ©Ÿæº¶åª’ã‚„æ¥ç€å‰¤ã¨ã—ã¦ä½¿ã‚ã‚Œã¾ã™ã€‚" 
        },
        "ãƒ¡ã‚¿ãƒ³é…¸ã‚¨ãƒãƒ«": { 
            name: "ã‚®é…¸ã‚¨ãƒãƒ« (Ethyl Formate)", 
            note: "ğŸ“ ãƒ©ã‚ºãƒ™ãƒªãƒ¼ã®é¦™ã‚Šã®æˆåˆ†ã‚’æŒã¤ä»£è¡¨çš„ãªã‚¨ã‚¹ãƒ†ãƒ«ã€‚é¦™æ–™ã‚„é£Ÿå“æ·»åŠ ç‰©ã¨ã—ã¦ãƒ•ãƒ¬ãƒ¼ãƒãƒ¼ã«åˆ©ç”¨ã•ã‚Œã¾ã™ã€‚" 
        }

        // å¿…è¦ã«å¿œã˜ã¦ã“ã“ã«æ–°ã—ã„æ…£ç”¨åã¨å‚™è€ƒã‚’è¿½åŠ ã—ã¦ãã ã•ã„
    };

    // â˜…â˜…â˜… è¿½è¨˜: ã‚¨ã‚¹ãƒ†ãƒ«çµåˆã«ä½¿ã‚ã‚ŒãŸé…¸ç´ åŸå­ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’ä¿æŒã™ã‚‹ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•° â˜…â˜…â˜…
    let ESTER_OXY_INDICES = []; 

    // --- ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°ç¾¤ ---
    function getValence(atomType) {
      if (atomType === 'C') return 4;
      if (atomType === 'H') return 1;
      if (atomType === 'O') return 2;
      return 0;
    }

    function getAtomType(markerId) {
      if (!markerId) return 'unknown';
      if (markerId.startsWith('carbon')) return 'C'; 
      if (markerId.startsWith('hydrogen')) return 'H';
      if (markerId.startsWith('oxygen')) return 'O';
      if (markerId.startsWith('double')) return 'double-bond';
      if (markerId.startsWith('triple')) return 'triple-bond';
      return 'unknown'; 
    }
    
    function createBondCylinder(startPos, endPos, radius, color, offset, bondOrder) {
        const dx = startPos.x - endPos.x;
        const dy = startPos.y - endPos.y;
        const dz = startPos.z - endPos.z;
        const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
        const midPos = {
            x: (startPos.x + endPos.x) / 2 + (offset * (dy/distance || 0)),
            y: (startPos.y + endPos.y) / 2 + (offset * (-dx/distance || 0)),
            z: (startPos.z + endPos.z) / 2, 
        };
        const rotationY = Math.atan2(dx, dy) * (180 / Math.PI);
        const cylinder = document.createElement('a-cylinder');
        cylinder.setAttribute('radius', radius);
        cylinder.setAttribute('height', distance);
        cylinder.setAttribute('color', color);
        cylinder.setAttribute('position', `${midPos.x} ${midPos.y} ${midPos.z}`);
        cylinder.setAttribute('rotation', `0 0 ${-rotationY}`); 
        cylinder.setAttribute('data-bond-order', bondOrder);
        return cylinder;
    }

    function registerBond(atomA, atomB, bondValue) {
        if ((atomA.type === 'H' || atomB.type === 'H') && bondValue > 1) bondValue = 1;
        if (atomA.valenceUsed + bondValue > getValence(atomA.type) || atomB.valenceUsed + bondValue > getValence(atomB.type)) return false; 
        let isAlreadyBonded = MOLECULE_GRAPH.bonds.some(b => (b.atom1 === atomA.atomIndex && b.atom2 === atomB.atomIndex) || (b.atom2 === atomA.atomIndex && b.atom1 === atomB.atomIndex));
        if (isAlreadyBonded) return false;

        MOLECULE_GRAPH.bonds.push({
            atom1: atomA.atomIndex, atom2: atomB.atomIndex, order: bondValue, 
            type: bondValue === 1 ? '-' : (bondValue === 2 ? '=' : 'â‰¡'),
            atomAEl: atomA.markerEl, atomBEl: atomB.markerEl
        });
        atomA.valenceUsed += bondValue;
        atomB.valenceUsed += bondValue;
        return true;
    }
    
    function toMarkerLocalCoords(marker, globalPos) {
        const markerPos = marker.object3D.position;
        const rotation = marker.object3D.rotation.z; 
        const dx = globalPos.x - markerPos.x;
        const dy = globalPos.y - markerPos.y;
        const dz = globalPos.z - markerPos.z;
        const cos = Math.cos(-rotation);
        const sin = Math.sin(-rotation);
        return { x: dx * cos - dy * sin, y: dx * sin + dy * cos, z: dz };
    }

    // â˜…â˜…â˜… 1. æœ€é•·ç‚­ç´ é–ã®ã€Œãƒ‘ã‚¹ï¼ˆåŸå­ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹é…åˆ—ï¼‰ã€ã‚’å–å¾—ã™ã‚‹é–¢æ•° â˜…â˜…â˜…
    function findLongestChainPath(detectedAtoms, moleculeGraph) {
        const carbonIndices = detectedAtoms.map((a, i) => a.isCarbon ? i : -1).filter(i => i !== -1);
        if (carbonIndices.length === 0) return [];

        // éš£æ¥ãƒªã‚¹ãƒˆä½œæˆ
        const adjacency = {};
        carbonIndices.forEach(i => adjacency[i] = []);
        moleculeGraph.bonds.forEach(bond => {
            if (detectedAtoms[bond.atom1].isCarbon && detectedAtoms[bond.atom2].isCarbon) {
                adjacency[bond.atom1].push(bond.atom2);
                adjacency[bond.atom2].push(bond.atom1);
            }
        });

        let longestPath = [];

        function dfs(currentPath) {
            const currentNode = currentPath[currentPath.length - 1];
            const neighbors = adjacency[currentNode];
            let isLeaf = true;

            for (const neighbor of neighbors) {
                if (!currentPath.includes(neighbor)) {
                    isLeaf = false;
                    dfs([...currentPath, neighbor]);
                }
            }

            if (isLeaf) {
                if (currentPath.length > longestPath.length) {
                    longestPath = currentPath;
                }
            }
        }

        carbonIndices.forEach(startIndex => dfs([startIndex]));
        return longestPath;
    }

    // â˜…â˜…â˜… 2. ä¸»è¦å®˜èƒ½åŸºã®ç‰¹å®š (ä½ç½®æƒ…å ±ä»˜ã) â˜…â˜…â˜…
    function identifyPrincipalGroup(detectedAtoms, bonds, mainChainPath) {
        let candidates = [];
        // â˜…â˜…â˜… ä¿®æ­£ç‚¹ 1-1: ã‚¨ã‚¹ãƒ†ãƒ«Oã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã®åˆæœŸåŒ– â˜…â˜…â˜…
        ESTER_OXY_INDICES = []; 
        
        // çµåˆæƒ…å ±ã‹ã‚‰éš£æ¥ãƒãƒƒãƒ—ä½œæˆ
        const getNeighbors = (idx) => {
            const n = [];
            bonds.forEach(b => {
                if (b.atom1 === idx) n.push({idx: b.atom2, order: b.order});
                else if (b.atom2 === idx) n.push({idx: b.atom1, order: b.order});
            });
            return n;
        };
        
        // Cé–ã®ç‚­ç´ æ•°ã‚’ã‚«ã‚¦ãƒ³ãƒˆ (DFS)
        function countCarbonChain(startIdx, stopIdx, bonds) {
            let count = 0;
            let visited = new Set([stopIdx]); 
            function countC(idx) {
                count++;
                visited.add(idx);
                getNeighbors(idx).forEach(neighbor => {
                    const next = neighbor.idx;
                    // Cã®ã¿ã‚’è¾¿ã‚Šã€æ—¢ã«è¨ªå•ã—ãŸåŸå­ã‚„åœæ­¢ç‚¹ã‚’ç„¡è¦–
                    if (detectedAtoms[next].isCarbon && !visited.has(next)) {
                        countC(next);
                    }
                });
            }
            countC(startIdx);
            return count;
        }


        // ä¸»é–ä¸Šã®å„ç‚­ç´ ã«ã¤ã„ã¦å®˜èƒ½åŸºã‚’ãƒã‚§ãƒƒã‚¯
        mainChainPath.forEach(cIndex => {
            const neighbors = getNeighbors(cIndex);
            const atomC = detectedAtoms[cIndex];

            // ã‚«ãƒ«ãƒœãƒ‹ãƒ«ç³» C=O
            const doubleO = neighbors.find(n => detectedAtoms[n.idx].isOxygen && n.order === 2);
            if (doubleO) {
                const singleO = neighbors.find(n => detectedAtoms[n.idx].isOxygen && n.order === 1);

                if (singleO) {
                    const oNeighbors = getNeighbors(singleO.idx);
                    
                    // 1. ã‚«ãƒ«ãƒœãƒ³é…¸ (-COOH)
                    if (oNeighbors.some(n => detectedAtoms[n.idx].isHydrogen)) {
                        candidates.push({ group: FUNCTIONAL_GROUPS.find(g => g.type === "CARBOXYLIC"), atomIndex: cIndex });
                        return;
                    }
                    
                    // 2. ã‚¨ã‚¹ãƒ†ãƒ« (-COO-R') ã®æ¤œå‡º
                    const RPrimeC = oNeighbors.find(n => detectedAtoms[n.idx].isCarbon && !mainChainPath.includes(n.idx));
                    if (RPrimeC) {
                        const RPrimeFirstCIndex = RPrimeC.idx;
                        const RPrimeChainLength = countCarbonChain(RPrimeFirstCIndex, singleO.idx, bonds);
                        
                        candidates.push({ 
                            group: FUNCTIONAL_GROUPS.find(g => g.type === "ESTER"), 
                            atomIndex: cIndex, 
                            RPrimeLength: RPrimeChainLength 
                        });
                        // â˜…â˜…â˜… ä¿®æ­£ç‚¹ 1-2: ã‚¨ã‚¹ãƒ†ãƒ«çµåˆã«ä½¿ã‚ã‚ŒãŸOã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’ä¿å­˜ â˜…â˜…â˜…
                        ESTER_OXY_INDICES.push(singleO.idx);
                        return;
                    }
                }
                
                // ä¸Šè¨˜ã§ãƒªã‚¿ãƒ¼ãƒ³ã•ã‚Œã¦ã„ãªã„å ´åˆ
                // ã‚¢ãƒ«ãƒ‡ãƒ’ãƒ‰ (-CHO)
                const chainNeighbors = neighbors.filter(n => mainChainPath.includes(n.idx));
                if (chainNeighbors.length <= 1 && neighbors.some(n => detectedAtoms[n.idx].isHydrogen)) {
                       candidates.push({ group: FUNCTIONAL_GROUPS.find(g => g.type === "ALDEHYDE"), atomIndex: cIndex });
                       return;
                }
                // ã‚±ãƒˆãƒ³
                candidates.push({ group: FUNCTIONAL_GROUPS.find(g => g.type === "KETONE"), atomIndex: cIndex });
                return;
            }

            // ã‚¢ãƒ«ã‚³ãƒ¼ãƒ« (-OH)
            // ä¸»é–Cã«å˜çµåˆOãŒã‚ã‚Šã€ãã®Oã«HãŒã¤ã„ã¦ã„ã‚‹
            const singleOH = neighbors.find(n => {
                if (detectedAtoms[n.idx].isOxygen && n.order === 1) {
                    const oNeighbors = getNeighbors(n.idx);
                    return oNeighbors.some(on => detectedAtoms[on.idx].isHydrogen);
                }
                return false;
            });
            if (singleOH) {
                candidates.push({ group: FUNCTIONAL_GROUPS.find(g => g.type === "ALCOHOL"), atomIndex: cIndex });
            }
        });

        // å¤šé‡çµåˆ (ã‚¢ãƒ«ã‚±ãƒ³/ã‚¢ãƒ«ã‚­ãƒ³)
        // ä¸»é–å†…ã®çµåˆã‚’ãƒã‚§ãƒƒã‚¯
        for (let i = 0; i < mainChainPath.length - 1; i++) {
            const u = mainChainPath[i];
            const v = mainChainPath[i+1];
            const bond = bonds.find(b => (b.atom1 === u && b.atom2 === v) || (b.atom2 === u && b.atom1 === v));
            if (bond) {
                if (bond.order === 3) candidates.push({ group: FUNCTIONAL_GROUPS.find(g => g.type === "ALKYNE"), atomIndex: u, atomIndex2: v }); // ä½ç½®ã¯å°ã•ã„ç•ªå·ã®C
                else if (bond.order === 2) candidates.push({ group: FUNCTIONAL_GROUPS.find(g => g.type === "ALKENE"), atomIndex: u, atomIndex2: v });
            }
        }

        if (candidates.length === 0) return { group: FUNCTIONAL_GROUPS.find(g => g.type === "ALKANE"), locants: [] };
        
        // å„ªå…ˆé †ä½ã§ã‚½ãƒ¼ãƒˆ
        candidates.sort((a, b) => a.group.priority - b.group.priority);
        const bestGroup = candidates[0].group;
        // åŒã˜å„ªå…ˆé †ä½ã®å®˜èƒ½åŸºãŒè¤‡æ•°ã‚ã‚‹å ´åˆã®ãŸã‚ã«ãƒªã‚¹ãƒˆåŒ–
        const principals = candidates.filter(c => c.group.type === bestGroup.type);
        
        return { group: bestGroup, occurrences: principals };
    }

    // â˜…â˜…â˜… 3. ç•ªå·ä»˜ã‘ã®æ–¹å‘æ±ºå®š (å¤‰æ›´ãªã—) â˜…â˜…â˜…
    function determineDirection(mainChainPath, principalInfo, substituents) {
        const len = mainChainPath.length;
        
        // ã‚¹ã‚³ã‚¢è¨ˆç®—é–¢æ•°: å°ã•ã„é…åˆ—ã®æ–¹ãŒã€Œå°ã•ã„ã€ã¨åˆ¤æ–­
        const compareArrays = (arr1, arr2) => {
            for (let i = 0; i < Math.min(arr1.length, arr2.length); i++) {
                if (arr1[i] < arr2[i]) return -1; // arr1ãŒå°ã•ã„
                if (arr1[i] > arr2[i]) return 1;  // arr2ãŒå°ã•ã„
            }
            if (arr1.length < arr2.length) return -1;
            if (arr1.length > arr2.length) return 1;
            return 0;
        };

        // ãƒ­ã‚«ãƒ³ãƒˆï¼ˆä½ç½®ç•ªå·ï¼‰ã®ãƒªã‚¹ãƒˆã‚’å–å¾— (1-based)
        const getLocants = (path) => {
            const mapIndexToLocant = {};
            path.forEach((atomIdx, i) => mapIndexToLocant[atomIdx] = i + 1);

            // 1. ä¸»è¦å®˜èƒ½åŸºã®ä½ç½®
            const pLocants = principalInfo.occurrences ? principalInfo.occurrences.map(o => mapIndexToLocant[o.atomIndex]).sort((a,b)=>a-b) : [];
            
            // 2. ç½®æ›åŸºã®ä½ç½®
            const sLocants = substituents.map(s => mapIndexToLocant[s.rootAtomIndex]).sort((a,b)=>a-b);

            return { p: pLocants, s: sLocants };
        };

        const forwardLocants = getLocants(mainChainPath);
        const backwardLocants = getLocants([...mainChainPath].reverse());

        // ãƒ«ãƒ¼ãƒ«1: ä¸»è¦å®˜èƒ½åŸºãŒå°ã•ã„æ–¹
        if (principalInfo.group.type !== "ALKANE") {
            const cmp = compareArrays(forwardLocants.p, backwardLocants.p);
            if (cmp < 0) return mainChainPath;
            if (cmp > 0) return [...mainChainPath].reverse();
        }

        // ãƒ«ãƒ¼ãƒ«2: ç½®æ›åŸºãŒå°ã•ã„æ–¹ (å¤šé‡çµåˆã¯ä¸»è¦å®˜èƒ½åŸºã«å«ã¾ã‚Œã‚‹ãŸã‚ã“ã“ã§å‡¦ç†æ¸ˆã¿)
        const cmpS = compareArrays(forwardLocants.s, backwardLocants.s);
        if (cmpS < 0) return mainChainPath;
        if (cmpS > 0) return [...mainChainPath].reverse();

        return mainChainPath; // ã©ã¡ã‚‰ã§ã‚‚åŒã˜
    }

// â˜…â˜…â˜… 4. ç½®æ›åŸºã®ç‰¹å®š (ã‚¨ãƒ¼ãƒ†ãƒ«å‘½åè¦å‰‡ã‚’åæ˜ ) â˜…â˜…â˜…
    function identifySubstituents(detectedAtoms, bonds, mainChainPath) {
        let subs = [];
        let visitedOxygens = new Set();
        
        const getNeighbors = (idx) => {
            const n = [];
            bonds.forEach(b => {
                if (b.atom1 === idx) n.push(b.atom2);
                else if (b.atom2 === idx) n.push(b.atom1);
            });
            return n;
        };

        // Cé–ã®ç‚­ç´ æ•°ã‚’ã‚«ã‚¦ãƒ³ãƒˆ (DFS)
        function countCarbonChain(startIdx, stopIdx) {
            let count = 0;
            let visited = new Set([stopIdx]); // é€£çµç‚¹ã¾ãŸã¯æ¢ç´¢çµ‚äº†ç‚¹
            function countC(idx) {
                count++;
                visited.add(idx);
                getNeighbors(idx).forEach(next => {
                    // Cã®ã¿ã‚’è¾¿ã‚Šã€æ—¢ã«è¨ªå•ã—ãŸåŸå­ã‚„åœæ­¢ç‚¹ã‚’ç„¡è¦–
                    if (detectedAtoms[next].isCarbon && !visited.has(next)) countC(next);
                });
            }
            countC(startIdx);
            return count;
        }


        detectedAtoms.forEach((atom, idx) => {
            // â˜…â˜…â˜… ä¿®æ­£ç‚¹ 2: ã‚¨ã‚¹ãƒ†ãƒ«ã«ä½¿ã‚ã‚ŒãŸOåŸå­ã¯ã‚¢ãƒ«ã‚³ã‚­ã‚·åŸºã¨ã—ã¦ã‚«ã‚¦ãƒ³ãƒˆã—ãªã„ â˜…â˜…â˜…
            if (ESTER_OXY_INDICES.includes(idx)) {
                visitedOxygens.add(idx);
                return;
            }
            
            if (atom.isOxygen && !visitedOxygens.has(idx)) {
                const neighbors = getNeighbors(idx);
                const carbonNeighbors = neighbors.filter(n => detectedAtoms[n].isCarbon && n !== idx);
                
                // ã‚¨ãƒ¼ãƒ†ãƒ«æ§‹é€  C-O-C ã®æ¤œå‡º
                if (carbonNeighbors.length === 2 && atom.valenceUsed === 2) {
                    const cA = carbonNeighbors[0];
                    const cB = carbonNeighbors[1];
                    
                    // CåŸå­æ•°ã‚’ã‚«ã‚¦ãƒ³ãƒˆ (C-CçµåˆãŒã‚ã‚‹å ´åˆã€ãã®Cé–ã®é•·ã•å…¨ä½“ã‚’ã‚«ã‚¦ãƒ³ãƒˆ)
                    const countA = countCarbonChain(cA, idx);
                    const countB = countCarbonChain(cB, idx);

                    // ä¸»é–ã«å«ã¾ã‚Œã‚‹ã‹ã©ã†ã‹ã§åˆ¤æ–­
                    const cA_on_Main = mainChainPath.includes(cA);
                    const cB_on_Main = mainChainPath.includes(cB);

                    let mainSideC = -1;
                    let subSideC = -1;
                    let rootCIndex = -1;
                    
                    if (cA_on_Main && !cB_on_Main) { // AãŒä¸»é–ã€BãŒå´é–
                        mainSideC = cA;
                        subSideC = cB;
                        rootCIndex = cA;
                    } else if (!cA_on_Main && cB_on_Main) { // BãŒä¸»é–ã€AãŒå´é–
                        mainSideC = cB;
                        subSideC = cA;
                        rootCIndex = cB;
                    } else if (!cA_on_Main && !cB_on_Main) { // ä¸¡æ–¹å´é–ã®å ´åˆ (ã‚¨ãƒ¼ãƒ†ãƒ«ãŒä¸»é–ã«ã¶ã‚‰ä¸‹ãŒã£ã¦ã„ãªã„å ´åˆ)
                        // Cæ•°ã®å¤šã„æ–¹ãŒä¸»é–å´ã€å°‘ãªã„æ–¹ãŒå´é–å´ã«ãªã‚‹ã¹ãã ãŒã€
                        // ã“ã“ã§ã¯ä¸»é– (C-Cé–) ã«ã¯ç¹‹ãŒã£ã¦ã„ãªã„ãŒã€C-O-Cã¯å­˜åœ¨ã™ã‚‹å ´åˆã¨ã—ã¦ã€
                        // Cæ•°ã®å°‘ãªã„æ–¹ã‚’ã‚¢ãƒ«ã‚³ã‚­ã‚·åŸºã¨ã—ã¦æ‰±ã† (IUPACãƒ«ãƒ¼ãƒ«: ç‚­ç´ æ•°ã®å¤šã„æ–¹ã‚’è¦ªã‚¢ãƒ«ã‚«ãƒ³ã¨ã™ã‚‹)
                        if (countA >= countB) { // Bã‚’å´é–ã¨ã™ã‚‹
                            mainSideC = cA; 
                            subSideC = cB;
                            // ã©ã¡ã‚‰ã‚‚ä¸»é–ã«ç¹‹ãŒã£ã¦ãªã„ã®ã§ã€æœ€ã‚‚è¿‘ã„ä¸»é–Cã‚’æ ¹å…ƒã¨ã™ã‚‹ã®ãŒé›£ã—ã„ã€‚
                            // ä¾¿å®œä¸Šã€Cæ•°ã®å¤šã„å´ã‚’ã‚¢ãƒ«ã‚«ãƒ³ä¸»é–ã¨ã—ã¦æ‰±ã†ã€‚
                            rootCIndex = mainChainPath[0]; // æš«å®šçš„ã«ä¸»é–ã®æ ¹å…ƒã«ä½ç½®ä»˜ã‘
                        } else { // Aã‚’å´é–ã¨ã™ã‚‹
                            mainSideC = cB;
                            subSideC = cA;
                            rootCIndex = mainChainPath[0];
                        }
                    } else {
                        // ä¸¡æ–¹ä¸»é–ä¸Šã®å ´åˆ (ç’°çŠ¶/è¤‡é›‘) ã¯å‡¦ç†ã—ãªã„
                        return;
                    }
                    
                    if (subSideC !== -1) {
                        const subCount = (subSideC === cA) ? countA : countB;
                        
                        // Cæ•°ã«åŸºã¥ãã‚¢ãƒ«ã‚³ã‚­ã‚·å
                        let baseName = ALKYL_NAMES[subCount] || "ã‚¢ãƒ«ã‚­ãƒ«";
                        let oxyName = baseName.replace("ã‚¤ãƒ«", "ã‚ªã‚­ã‚·"); 
                        if (subCount === 1) oxyName = "ãƒ¡ãƒˆã‚­ã‚·"; 
                        if (subCount === 2) oxyName = "ã‚¨ãƒˆã‚­ã‚·";
                        
                        subs.push({ name: oxyName, rootAtomIndex: rootCIndex, type: 'ALKOXY' });
                        visitedOxygens.add(idx); // OåŸå­ã‚’ä½¿ç”¨æ¸ˆã¿ã¨ã—ã¦ãƒãƒ¼ã‚¯
                    }
                }
            }
        });


        // 5. Cå´é–ï¼ˆã‚¢ãƒ«ã‚­ãƒ«åŸºï¼‰ã®åˆ¤å®š (ã‚¨ãƒ¼ãƒ†ãƒ«ã«ä½¿ç”¨ã•ã‚Œãªã‹ã£ãŸCé–ã®ã¿)
        mainChainPath.forEach(rootIdx => {
            const neighbors = getNeighbors(rootIdx);
            neighbors.forEach(nIdx => {
                if (!mainChainPath.includes(nIdx) && detectedAtoms[nIdx].isCarbon) {
                    // æ—¢ã«ã‚¨ãƒ¼ãƒ†ãƒ«ã¨ã—ã¦ã‚«ã‚¦ãƒ³ãƒˆã•ã‚ŒãŸCé–ã‚’é¿ã‘ã‚‹ãƒ­ã‚¸ãƒƒã‚¯ã¯è¤‡é›‘ãªãŸã‚ã€
                    // ã“ã“ã§ã¯å˜ã«ä¸»é–ã«ãªã„Cé–ã‚’ã‚¢ãƒ«ã‚­ãƒ«åŸºã¨ã—ã¦ã‚«ã‚¦ãƒ³ãƒˆã™ã‚‹ï¼ˆé‡è¤‡ã®å¯èƒ½æ€§ã‚ã‚Šï¼‰
                    
                    let count = 0;
                    let visited = new Set([rootIdx]); 
                    function countC(idx) {
                        count++;
                        visited.add(idx);
                        getNeighbors(idx).forEach(next => {
                            if (detectedAtoms[next].isCarbon && !visited.has(next) && !mainChainPath.includes(next)) {
                                countC(next);
                            }
                        });
                    }
                    countC(nIdx);
                    
                    if (count > 0 && count < ALKYL_NAMES.length) {
                        subs.push({ name: ALKYL_NAMES[count], rootAtomIndex: rootIdx, type: 'ALKYL' });
                    }
                }
            });
        });
        
        return subs;
    }

    AFRAME.registerComponent('bond-analyzer', {
      init: function () {
        this.debugDiv = document.querySelector('#debug-div');
        this.analysisDiv = document.querySelector('#analysis-div'); 
        this.bondGroup = document.querySelector('#bond-group'); 
        // â˜…â˜…â˜… è¿½åŠ : æœ€å¾Œã®åˆ†æå®Ÿè¡Œæ™‚é–“ã¨æ›´æ–°é–“éš” (1000ms = 1ç§’) â˜…â˜…â˜…
        this.lastAnalysisTime = 0; 
        this.updateInterval = 100;
      },
      
      tick: function (time, timeDelta) {
        // â˜…â˜…â˜… 1ç§’çµŒéãƒã‚§ãƒƒã‚¯ â˜…â˜…â˜…
        // time ã¯ã‚·ãƒ¼ãƒ³é–‹å§‹ã‹ã‚‰ã®çµŒéæ™‚é–“ï¼ˆãƒŸãƒªç§’ï¼‰
        if (time - this.lastAnalysisTime < this.updateInterval) {
            return; // 1ç§’çµŒã£ã¦ã„ãªã‘ã‚Œã°ã€åˆ†æã¨æç”»ã‚’ã‚¹ã‚­ãƒƒãƒ—
        }
        this.lastAnalysisTime = time; // åˆ†æã‚’å®Ÿè¡Œã™ã‚‹æ™‚é–“ã‚’è¨˜éŒ²
        // â˜…â˜…â˜… ãƒã‚§ãƒƒã‚¯ã“ã“ã¾ã§ â˜…â˜…â˜…
        
        if (!this.debugDiv || !this.analysisDiv || !this.bondGroup) return; 

        while (this.bondGroup.firstChild) this.bondGroup.removeChild(this.bondGroup.firstChild);
        
        let localDetectedAtoms = [];
        let detectedBonds = [];
        let allMarkers = document.querySelectorAll('a-marker');
        
        allMarkers.forEach(marker => {
          if (!marker.object3D.visible) return; 
          let atomType = getAtomType(marker.id); 
          let markerData = { id: marker.id, type: atomType, pos: marker.object3D.position, valenceUsed: 0, atomIndex: -1, isHydrogen: atomType === 'H', isOxygen: atomType === 'O', isCarbon: atomType === 'C', markerEl: marker };
          if (atomType === 'C' || atomType === 'H' || atomType === 'O') localDetectedAtoms.push(markerData);
          else if (atomType === 'double-bond' || atomType === 'triple-bond') { markerData.used = false; detectedBonds.push(markerData); }
        });
        
        let detectedAtoms = localDetectedAtoms;
        MOLECULE_GRAPH.atoms = []; MOLECULE_GRAPH.bonds = [];
        let isStable = true;
        let output = "";
        detectedAtoms.forEach((atom, index) => { atom.atomIndex = index; MOLECULE_GRAPH.atoms.push(atom.type); });
        
        // --- çµåˆåˆ¤å®šãƒ­ã‚¸ãƒƒã‚¯ (å¤‰æ›´ãªã—) ---
        // 1. O-C (C=O)
        for (let i = 0; i < detectedAtoms.length; i++) {
            let atomO = detectedAtoms[i]; if (!atomO.isOxygen) continue;
            for (let j = 0; j < detectedAtoms.length; j++) {
                let atomC = detectedAtoms[j]; if (i === j || !atomC.isCarbon) continue;
                if (Math.sqrt(Math.pow(atomO.pos.x - atomC.pos.x, 2) + Math.pow(atomO.pos.y - atomC.pos.y, 2)) < ATOM_BOND_THRESHOLD) {
                    let bondValue = 1; let markerUsed = null;
                    for (let bondMarker of detectedBonds) {
                        if (bondMarker.used) continue;
                        let distA = Math.sqrt(Math.pow(atomO.pos.x - bondMarker.pos.x, 2) + Math.pow(atomO.pos.y - bondMarker.pos.y, 2));
                        let distB = Math.sqrt(Math.pow(atomC.pos.x - bondMarker.pos.x, 2) + Math.pow(atomC.pos.y - bondMarker.pos.y, 2));
                        if (distA < MULTIPLE_BOND_ATOM_THRESHOLD && distB < MULTIPLE_BOND_ATOM_THRESHOLD) {
                            const localA = toMarkerLocalCoords(bondMarker.markerEl, atomO.pos);
                            const localB = toMarkerLocalCoords(bondMarker.markerEl, atomC.pos);
                            const isLateral = (localA.x * localB.x < 0) && (Math.abs(localA.y) < LATERAL_DISTANCE_THRESHOLD) && (Math.abs(localB.y) < LATERAL_DISTANCE_THRESHOLD);
                            if (isLateral && bondMarker.type === 'double-bond') { bondValue = 2; markerUsed = bondMarker; break; }
                        }
                    }
                    if (bondValue === 2) {
                        let existing = MOLECULE_GRAPH.bonds.findIndex(b => (b.atom1 === i && b.atom2 === j) || (b.atom2 === i && b.atom1 === j));
                        if (existing !== -1) { let b = MOLECULE_GRAPH.bonds[existing]; atomO.valenceUsed-=b.order; atomC.valenceUsed-=b.order; MOLECULE_GRAPH.bonds.splice(existing, 1); }
                        if (registerBond(atomO, atomC, 2)) markerUsed.used = true; 
                    }
                }
            }
        }
        // 2. C-C å¤šé‡
        for (let i = 0; i < detectedAtoms.length; i++) {
            let atomA = detectedAtoms[i]; if (!atomA.isCarbon) continue;
            for (let j = i + 1; j < detectedAtoms.length; j++) {
                let atomB = detectedAtoms[j]; if (!atomB.isCarbon) continue;
                if (MOLECULE_GRAPH.bonds.some(b => (b.atom1 === i && b.atom2 === j) || (b.atom2 === i && b.atom1 === j))) continue;
                if (Math.sqrt(Math.pow(atomA.pos.x - atomB.pos.x, 2) + Math.pow(atomA.pos.y - atomB.pos.y, 2)) < ATOM_BOND_THRESHOLD) {
                    let bondValue = 1; let markerUsed = null;
                    for (let bondMarker of detectedBonds) {
                        if (bondMarker.used) continue;
                        let distA = Math.sqrt(Math.pow(atomA.pos.x - bondMarker.pos.x, 2) + Math.pow(atomA.pos.y - bondMarker.pos.y, 2));
                        let distB = Math.sqrt(Math.pow(atomB.pos.x - bondMarker.pos.x, 2) + Math.pow(atomB.pos.y - bondMarker.pos.y, 2));
                        if (distA < MULTIPLE_BOND_ATOM_THRESHOLD && distB < MULTIPLE_BOND_ATOM_THRESHOLD) {
                            const localA = toMarkerLocalCoords(bondMarker.markerEl, atomA.pos);
                            const localB = toMarkerLocalCoords(bondMarker.markerEl, atomB.pos);
                            const isLateral = (localA.x * localB.x < 0) && (Math.abs(localA.y) < LATERAL_DISTANCE_THRESHOLD) && (Math.abs(localB.y) < LATERAL_DISTANCE_THRESHOLD);
                            if (isLateral) { 
                                if (bondMarker.type === 'triple-bond') { bondValue = 3; markerUsed = bondMarker; break; }
                                if (bondMarker.type === 'double-bond') { bondValue = 2; markerUsed = bondMarker; break; } 
                            }
                        }
                    }
                    if (bondValue > 1) { if (registerBond(atomA, atomB, bondValue)) markerUsed.used = true; }
                }
            }
        }
        // 3. Hçµåˆ
        const rightH = ['hydrogen-1', 'hydrogen-2', 'hydrogen-3'];
        const downH = ['hydrogen-4', 'hydrogen-5', 'hydrogen-6', 'hydrogen-7'];
        for (let i = 0; i < detectedAtoms.length; i++) {
            let atomA = detectedAtoms[i];
            if (atomA.isHydrogen) {
                let closest = null; let minD = ATOM_BOND_THRESHOLD;
                const isR = rightH.includes(atomA.id); const isD = downH.includes(atomA.id);
                for (let j = 0; j < detectedAtoms.length; j++) {
                    let atomB = detectedAtoms[j]; if (i === j || atomB.isHydrogen) continue;
                    if (MOLECULE_GRAPH.bonds.some(b => (b.atom1 === i && b.atom2 === j) || (b.atom2 === i && b.atom1 === j))) continue;
                    let d = Math.sqrt(Math.pow(atomA.pos.x - atomB.pos.x, 2) + Math.pow(atomA.pos.y - atomB.pos.y, 2));
                    if (d < minD) {
                        if (atomB.valenceUsed < getValence(atomB.type)) {
                            const local = toMarkerLocalCoords(atomA.markerEl, atomB.pos);
                            let valid = true;
                            if (isR) { if (!(local.x > 0 && Math.abs(local.y) < H_DIRECTION_TOLERANCE)) valid = false; }
                            else if (isD) { if (!(local.y < 0 && Math.abs(local.x) < H_DIRECTION_TOLERANCE)) valid = false; }
                            if (valid) { minD = d; closest = atomB; }
                        }
                    }
                }
                if (closest) registerBond(atomA, closest, 1);
            }
        }
        // 4. Oçµåˆ
        const oIndices = detectedAtoms.map((a, i) => a.isOxygen ? i : -1).filter(i => i !== -1);
        for (const i of oIndices) {
            let atomO = detectedAtoms[i];
            if (atomO.valenceUsed >= 2) continue;
            let neighbors = [];
            for (let j = 0; j < detectedAtoms.length; j++) {
                let atomX = detectedAtoms[j]; if (i === j || atomX.isHydrogen) continue;
                let currentBond = MOLECULE_GRAPH.bonds.filter(b => (b.atom1 === i && b.atom2 === j) || (b.atom2 === i && b.atom1 === j)).reduce((s, b) => s + b.order, 0);
                if (currentBond < getValence(atomO.type) && currentBond < getValence(atomX.type)) {
                    let d = Math.sqrt(Math.pow(atomO.pos.x - atomX.pos.x, 2) + Math.pow(atomO.pos.y - atomX.pos.y, 2));
                    if (d < ATOM_BOND_THRESHOLD) neighbors.push({ atom: atomX, dist: d });
                }
            }
            neighbors.sort((a, b) => a.dist - b.dist);
            const hCount = MOLECULE_GRAPH.bonds.filter(b => ((b.atom1 === i && detectedAtoms[b.atom2].isHydrogen) || (b.atom2 === i && detectedAtoms[b.atom1].isHydrogen))).length;
            let tryCount = 2 - atomO.valenceUsed; if (hCount >= 1) tryCount = 1;
            let done = 0;
            for (const n of neighbors) {
                if (done >= tryCount) break;
                let should = (hCount >= 1) || (atomO.valenceUsed < 2);
                if (should && registerBond(atomO, n.atom, 1)) done++;
            }
        }
        // 5. Cå˜çµåˆ
        for (let i = 0; i < detectedAtoms.length; i++) {
            let atomA = detectedAtoms[i]; if (!atomA.isCarbon) continue;
            for (let j = i + 1; j < detectedAtoms.length; j++) {
                let atomB = detectedAtoms[j]; if (atomB.isHydrogen) continue;
                if (MOLECULE_GRAPH.bonds.some(b => (b.atom1 === i && b.atom2 === j) || (b.atom2 === i && b.atom1 === j))) continue;
                let d = Math.sqrt(Math.pow(atomA.pos.x - atomB.pos.x, 2) + Math.pow(atomA.pos.y - atomB.pos.y, 2));
                if (d < ATOM_BOND_THRESHOLD) {
                    if (atomA.valenceUsed < 4 && atomB.valenceUsed < getValence(atomB.type)) registerBond(atomA, atomB, 1);
                }
            }
        }
        // (çµåˆåˆ¤å®šãƒ­ã‚¸ãƒƒã‚¯ã“ã“ã¾ã§)


        // æç”»
        MOLECULE_GRAPH.bonds.forEach(b => {
            const posA = b.atomAEl.object3D.position; const posB = b.atomBEl.object3D.position;
            const color = b.order === 1 ? '#8E80BB' : (b.order === 2 ? '#E2C64F' : '#66c3c2');
            if (b.order === 1) this.bondGroup.appendChild(createBondCylinder(posA, posB, BOND_RADIUS, color, 0, 1));
            else if (b.order > 1) {
                this.bondGroup.appendChild(createBondCylinder(posA, posB, BOND_RADIUS, color, MULTIPLE_BOND_OFFSET, 1));
                this.bondGroup.appendChild(createBondCylinder(posA, posB, BOND_RADIUS, color, -MULTIPLE_BOND_OFFSET, 1));
                if (b.order === 3) this.bondGroup.appendChild(createBondCylinder(posA, posB, BOND_RADIUS, color, 0, 1));
            }
        });
        
        for (let i = 0; i < detectedAtoms.length; i++) {
            let a = detectedAtoms[i];
            let t = a.markerEl.querySelector('a-text');
            if(t) t.setAttribute('value', `${a.type}${i+1} (${a.valenceUsed}/${getValence(a.type)})`);
            if (a.valenceUsed > getValence(a.type)) { isStable = false;}
            else if (a.valenceUsed < getValence(a.type) && detectedAtoms.length > 1) { if (a.isCarbon||a.isOxygen) { isStable = false;} }
        }
        if (isStable && detectedAtoms.length>0) { output += "å®‰å®š"; this.debugDiv.style.color = '#66c3c2'; }
        else { this.debugDiv.style.color = '#db6172'; output += "ä¸å®‰å®š"; }
        this.debugDiv.innerText = output;

        // ============================================================
        // â˜…â˜…â˜… IUPACå‘½åç”Ÿæˆãƒ­ã‚¸ãƒƒã‚¯ (çµ±åˆ) â˜…â˜…â˜…
        // ============================================================
        
        // 1. æœ€é•·ç‚­ç´ é–ãƒ‘ã‚¹ã®å–å¾—
        const mainPath = findLongestChainPath(detectedAtoms, MOLECULE_GRAPH);
        const mainLen = mainPath.length;
        
        if (mainLen > 0) {
            // 2. ä¸»è¦å®˜èƒ½åŸºã®ç‰¹å®š
            const pInfo = identifyPrincipalGroup(detectedAtoms, MOLECULE_GRAPH.bonds, mainPath);
            
            // 3. ç½®æ›åŸºå€™è£œã®æ¤œå‡º (ä¸»é–ã‹ã‚‰ã¶ã‚‰ä¸‹ãŒã£ã¦ã„ã‚‹ã‚‚ã®)
            const rawSubs = identifySubstituents(detectedAtoms, MOLECULE_GRAPH.bonds, mainPath);
            
            // 4. ç•ªå·ä»˜ã‘ (æ–¹å‘æ±ºå®š)
            const orderedPath = determineDirection(mainPath, pInfo, rawSubs);
            
            // ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ -> ãƒ­ã‚«ãƒ³ãƒˆ(1,2,3...) ã®ãƒãƒƒãƒ—ä½œæˆ
            const locantMap = {};
            orderedPath.forEach((idx, i) => locantMap[idx] = i + 1);
            
            // 5. åç§°æ§‹ç¯‰
            
            // æ¥é ­è¾ (Prefix) éƒ¨åˆ†: ç½®æ›åŸº
            let prefixParts = [];
            let subGroups = {}; // åå‰ã”ã¨ã«ã¾ã¨ã‚ã‚‹
            rawSubs.forEach(s => {
                if (!subGroups[s.name]) subGroups[s.name] = [];
                subGroups[s.name].push(locantMap[s.rootAtomIndex]);
            });
            
            // ç½®æ›åŸºã‚’ã‚½ãƒ¼ãƒˆã—ã¦æ–‡å­—åˆ—åŒ– (ä¾‹: 2,3-ã‚¸ãƒ¡ãƒãƒ«)
            Object.keys(subGroups).sort().forEach(name => {
                const locs = subGroups[name].sort((a,b)=>a-b);
                const numPrefix = NUMERAL_PREFIXES[locs.length] || "";
                prefixParts.push(`${locs.join(',')}-${numPrefix}${name}`);
            });
            const prefixStr = prefixParts.join(''); 

            // ä¸»é–å (Parent)
            let parentName = (mainLen < ALKANE_NAMES.length) ? ALKANE_NAMES[mainLen] : `C${mainLen}`;
            
            // ã‚¢ãƒ«ã‚±ãƒ³ãƒ»ã‚¢ãƒ«ã‚­ãƒ³ã®å‡¦ç† (èªå°¾å¤‰åŒ–: ã‚¢ãƒ³ -> ã‚¨ãƒ³/ã‚¤ãƒ³)
            let enYneSuffix = "";
            let doubleBondLocants = [];
            let tripleBondLocants = [];
            for(let k=0; k<orderedPath.length-1; k++) {
                let u = orderedPath[k], v = orderedPath[k+1];
                let bond = MOLECULE_GRAPH.bonds.find(b => (b.atom1===u && b.atom2===v) || (b.atom2===u && b.atom1===v));
                if(bond && bond.order === 2) doubleBondLocants.push(k+1);
                if(bond && bond.order === 3) tripleBondLocants.push(k+1);
            }
            
            if (doubleBondLocants.length > 0) {
                parentName = parentName.replace("ãƒ³", ""); 
                let locStr = doubleBondLocants.join(',');
                let numPre = NUMERAL_PREFIXES[doubleBondLocants.length] || "";
                enYneSuffix += `-${locStr}-${numPre}ã‚¨ãƒ³`;
            }
            if (tripleBondLocants.length > 0) {
                if (doubleBondLocants.length === 0) parentName = parentName.replace("ãƒ³", "");
                let locStr = tripleBondLocants.join(',');
                let numPre = NUMERAL_PREFIXES[tripleBondLocants.length] || "";
                enYneSuffix += `-${locStr}-${numPre}ã‚¤ãƒ³`;
            }

            // æ¥å°¾è¾ (Suffix)
            let suffixStr = "";
            let esterAlkylGroup = ""; // ã‚¨ã‚¹ãƒ†ãƒ«å‘½åç”¨ã®ã‚¢ãƒ«ã‚­ãƒ«åŸºå

            if (pInfo.group.type === "ESTER") {
                // ã‚¨ã‚¹ãƒ†ãƒ«å‘½åãƒ­ã‚¸ãƒƒã‚¯ (ã“ã®éƒ¨åˆ†ã¯å‰å›ã®ä¿®æ­£ã§ã¯å•é¡Œãªã‹ã£ãŸéƒ¨åˆ†)
                const esterOccurrence = pInfo.occurrences[0]; 
                const RPrimeLength = esterOccurrence.RPrimeLength;
                const alkylName = ALKYL_NAMES[RPrimeLength] || `C${RPrimeLength}ã‚¢ãƒ«ã‚­ãƒ«`;
                
                esterAlkylGroup = `${alkylName}`;
                
                suffixStr = `-${pInfo.group.suffix}`; // -é…¸
                
                // ã‚¨ã‚¹ãƒ†ãƒ«å‘½åã§ã¯ãƒ­ã‚«ãƒ³ãƒˆã¯ä¸è¦
                enYneSuffix = enYneSuffix.replace(/-[0-9,]+-/g, '-'); 
                parentName = parentName.replace("ãƒ³", ""); // ãƒ¡ã‚¿/ã‚¨ã‚¿...ã‚’æ®‹ã™ï¼ˆæ—¥æœ¬èªIUPACåã«å¤‰æ›ã™ã‚‹éš›ã«ã€Œãƒ³ã€ã‚’æˆ»ã™ï¼‰

            } else if (pInfo.group.type !== "ALKANE" && pInfo.group.type !== "ALKENE" && pInfo.group.type !== "ALKYNE" && pInfo.group.type !== "ETHER") {
                // ã‚¢ãƒ«ã‚³ãƒ¼ãƒ«ã€ã‚±ãƒˆãƒ³ã€ã‚¢ãƒ«ãƒ‡ãƒ’ãƒ‰ã€ã‚«ãƒ«ãƒœãƒ³é…¸
                let pLocs = pInfo.occurrences.map(o => locantMap[o.atomIndex]).sort((a,b)=>a-b);
                let locStr = pLocs.join(',');
                let numPre = NUMERAL_PREFIXES[pLocs.length] || "";
                
                suffixStr = `-${locStr}-${numPre}${pInfo.group.suffix}`;
                
                if ((pInfo.group.type === "ALDEHYDE" || pInfo.group.type === "CARBOXYLIC") && pLocs.length === 1 && pLocs[0] === 1) {
                    suffixStr = pInfo.group.suffix; 
                }
            }

            // æœ€çµ‚åã®æ§‹ç¯‰
            let finalName = "";
            if (pInfo.group.type === "ESTER") {
                 // ã‚¢ãƒ«ã‚­ãƒ«åŸºã®åç§° (ãƒ¡ãƒãƒ«) + ä¸»é–å (ã‚¨ã‚¿ãƒ³) + é…¸
                let carboxylicAcidPart = `${prefixStr}${parentName}ãƒ³${enYneSuffix}${suffixStr}`;
                // ãƒ¡ã‚¿(ãƒ³)é…¸ãƒ¡ãƒãƒ« / ã‚¨ã‚¿(ãƒ³)é…¸ãƒ¡ãƒãƒ« ã®å½¢ã«ã™ã‚‹ãŸã‚ã€ä¸€æ—¦å‰Šé™¤ã—ãŸã€Œãƒ³ã€ã‚’ã“ã“ã§æˆ»ã™ï¼ˆç°¡æ˜“å‡¦ç†ï¼‰
                // ãŸã ã—ã€enYneSuffixãŒå…¥ã‚‹ã¨ã€Œã‚¨ãƒ³é…¸ã€ã‚„ã€Œã‚¤ãƒ³é…¸ã€ã¨ãªã‚‹ã€‚
                
                carboxylicAcidPart = carboxylicAcidPart.replace(/^-/, "").replace(/--/g, "-").replace("ãƒ³-é…¸", "ãƒ³é…¸").replace(/-é…¸$/, 'é…¸').trim();
                
                finalName = `${carboxylicAcidPart} ${esterAlkylGroup}`; // æ—¥æœ¬èªã§ã¯ã‚«ãƒ«ãƒœãƒ³é…¸éƒ¨åˆ†ãŒå…ˆ
                
            } else {
                 // é€šå¸¸ã®å‘½åè¦å‰‡
                finalName = `${prefixStr}${parentName}${enYneSuffix}${suffixStr}`;
            }
            
            finalName = finalName.replace(/^-/, "").replace(/--/g, "-").trim();
            finalName = finalName.replace('é…¸-', 'é…¸-').replace('é…¸ ', 'é…¸');


            // â˜…â˜…â˜… æ–°æ©Ÿèƒ½: æ…£ç”¨åã®æ¤œç´¢ã¨è¡¨ç¤º (å¤‰æ›´ãªã—) â˜…â˜…â˜…
            const commonInfo = COMMON_NAMES[finalName];
            let commonNameDisplay = "";
            let komento = "";
            
            if (commonInfo) {
                commonNameDisplay = 
                    `æ…£ç”¨å: ${commonInfo.name}\n`;
                komento =  `\n${commonInfo.note}\n`; // å‚™è€ƒæ¬„ã‚’è¿½åŠ 
            }

            // è¡¨ç¤º
            this.analysisDiv.innerText =// `--- æ§‹é€ ã®åˆ†æ ---\n` +
                `IUPACå: ${finalName}\n` +
            //`ä¸»é–: C${mainLen} (${mainPath.join('-')})\n` + 
                commonNameDisplay +
                `å®˜èƒ½åŸº: ${pInfo.group.name}\n` +
                komento;  // æ…£ç”¨åã¨å‚™è€ƒã‚’è¿½åŠ 
        } else {
            this.analysisDiv.innerText = "ï¼¿ï¼¿ï¼¿ï¼¿ï¼¿ åŒ–åˆç‰©åˆ†æã‚«ãƒ¡ãƒ© ï¼¿ï¼¿ï¼¿ï¼¿ï¼¿\nã‚«ãƒ¼ãƒ‰ã‚’ã‚«ãƒ¡ãƒ©ã§èª­ã¿å–ã‚Šã¾ã™";
        }
      }
    });

    // â˜…â˜…â˜… æ–°æ©Ÿèƒ½: ã‚«ãƒ¡ãƒ©ã®ä¸€æ™‚åœæ­¢/å†ç”Ÿæ©Ÿèƒ½ â˜…â˜…â˜…
    let isPaused = false;
    
    // ä¸€æ™‚åœæ­¢/å†ç”Ÿãƒœã‚¿ãƒ³ã®å‡¦ç†
    function togglePause() {
        const scene = document.querySelector('a-scene');
        const button = document.querySelector('#pause-toggle-button');
        const icon = document.querySelector('#pause-icon');
        
        if (isPaused) {
            // å†ç”Ÿ (ä¸€æ™‚åœæ­¢è§£é™¤)
            scene.play(); // A-Frameã®ã‚·ãƒ¼ãƒ³ã‚’å†é–‹
            isPaused = false;
            button.style.backgroundColor = 'rgba(66, 107, 225, 0.7)'; // é’è‰²
            icon.textContent = 'â™ â™'; // ã‚¢ã‚¤ã‚³ãƒ³ã‚’ä¸€æ™‚åœæ­¢ã«å¤‰æ›´
            document.querySelector('#analysis-div').innerText = "è§£æä¸­..."; // ç”»é¢è¡¨ç¤ºã‚’æ›´æ–°
        } else {
            // ä¸€æ™‚åœæ­¢
            scene.pause(); // A-Frameã®ã‚·ãƒ¼ãƒ³ã‚’ä¸€æ™‚åœæ­¢
            isPaused = true;
            button.style.backgroundColor = 'rgba(219, 97, 114, 0.8)'; // èµ¤è‰²
            icon.textContent = 'â–¶ï¸'; // ã‚¢ã‚¤ã‚³ãƒ³ã‚’å†ç”Ÿã«å¤‰æ›´
            //document.querySelector('#analysis-div').innerText = "ã€ä¸€æ™‚åœæ­¢ä¸­ã€‘\n\n" + 
            document.querySelector('#analysis-div').innerText; // ç”»é¢è¡¨ç¤ºã‚’æ›´æ–°
        }
        
        // ãƒ‡ãƒãƒƒã‚°è¡¨ç¤ºã‚‚æ›´æ–°
        document.querySelector('#debug-div').innerText = isPaused ? "ä¸€æ™‚åœæ­¢" : "ARçµåˆåˆ†æAI";
    }
    
    // ãƒšãƒ¼ã‚¸ãƒ­ãƒ¼ãƒ‰å®Œäº†å¾Œã€ãƒœã‚¿ãƒ³ã«ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’ç™»éŒ²
    window.onload = function() {
        document.getElementById('pause-toggle-button').addEventListener('click', togglePause);
    };

  </script>
    
  <head>
    <meta charset="utf-8">
    <style>
      #debug-div { 
        position: absolute; 
        top: 13px; /* å·¦ä¸‹ã«å¤‰æ›´ */
        left: 20px; 
        z-index: 999; 
        color: white; 
        font-family: monospace; 
        font-size: 27px; 
        background: rgba(255,255,255,1); 
        padding: 5px; 
        white-space: pre-wrap; 
        border: 5px solid #2b2a54; 
        border-radius: 10px;
      }
      #analysis-div { 
        position: absolute; 
        top: 60%; /* å·¦ä¸Šã«å¤‰æ›´ */
        left: 40%;               /* å·¦ç«¯ã‹ã‚‰50%ã®ä½ç½® */
  transform: translateX(-50%); /* ä¸­å¤®ã«å¯„ã›ã‚‹ãŸã‚ã®èª¿æ•´ */
        z-index: 999; 
        width: 70%; 
        color: #2b2a54; 
        font-family: monospace; 
        font-size: 18px; 
        background: #FFFFFF; 
        padding: 10px; 
        white-space: pre-wrap; 
        text-align: center; /* å·¦å¯„ã›ã«å¤‰æ›´ */
        font-weight: bold; 
        border: 5px solid #2b2a54;
        border-radius: 50px;
      }
      #new-info-panel { 
  position: absolute; 
  top: -5px;               /* ä¸Šç«¯ã‹ã‚‰10px */
  left: 50%;               /* å·¦ç«¯ã‹ã‚‰50%ã®ä½ç½® */
  transform: translateX(-50%); /* ä¸­å¤®ã«å¯„ã›ã‚‹ãŸã‚ã®èª¿æ•´ */
  z-index: 99; 
  width: 100%;            /* å››è§’ã®å¹… */
  height: 55px;            /* é«˜ã•è‡ªå‹• */
  color: #FFFFFF;          /* æ–‡å­—è‰²ã‚’ç™½ã« */
  font-family: monospace; 
  font-size: 14px; 
  background: #66c3c2; /* æ¿ƒã„é’ã®èƒŒæ™¯ï¼ˆåŠé€æ˜ï¼‰ */
  padding: 10px; 
  text-align: center;      /* ä¸­å¤®æƒãˆ */
  border: 5px solid #2b2a54;
  background-image: url('benzen.png');
    background-size: 250px auto; /* ã‚µã‚¤ã‚ºã‚’æŒ‡å®š */
    background-repeat: repeat; /* ç¹°ã‚Šè¿”ã—ã‚’ãªã—ã« */
    background-position: center top; /* ä½ç½®ã‚’æŒ‡å®š */
}
#new-info-panel2 { 
  position: absolute; 
  bottom: -5px;               /* ä¸Šç«¯ã‹ã‚‰10px */
  left: 50%;               /* å·¦ç«¯ã‹ã‚‰50%ã®ä½ç½® */
  transform: translateX(-50%); /* ä¸­å¤®ã«å¯„ã›ã‚‹ãŸã‚ã®èª¿æ•´ */
  z-index: 99; 
  width: 100%;            /* å››è§’ã®å¹… */
  height: 30px;            /* é«˜ã•è‡ªå‹• */
  color: #FFFFFF;          /* æ–‡å­—è‰²ã‚’ç™½ã« */
  font-family: monospace; 
  font-size: 14px; 
  background: #66c3c2; /* æ¿ƒã„é’ã®èƒŒæ™¯ï¼ˆåŠé€æ˜ï¼‰ */
  padding: 10px; 
  text-align: center;      /* ä¸­å¤®æƒãˆ */
  border: 5px solid #2b2a54;
  background-image: url('benzen.png');
    background-size: 250px auto; /* ã‚µã‚¤ã‚ºã‚’æŒ‡å®š */
    background-repeat: repeat; /* ç¹°ã‚Šè¿”ã—ã‚’ãªã—ã« */
    background-position: center top; /* ä½ç½®ã‚’æŒ‡å®š */
}

/* â˜…â˜…â˜… æ–°è¦è¿½åŠ : ä¸€æ™‚åœæ­¢ãƒœã‚¿ãƒ³ã®ã‚¹ã‚¿ã‚¤ãƒ« â˜…â˜…â˜… */
      #pause-toggle-button {
          position: absolute;
          top: 8px;
          right: 20px;
          z-index: 1000; /* æœ€å‰é¢ã« */
          width: 50px;
          height: 50px;
          color: #FFFFFF;
          border-radius: 50%; /* ä¸¸å‹ */
          background-color: rgba(66, 107, 225, 0.7); /* åˆæœŸã¯é’ï¼ˆå†ç”Ÿä¸­ï¼‰ */
          border: 4px solid #FFFFFF;
          box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
          cursor: pointer;
          display: flex;
          align-items: center;
          justify-content: center;
          transition: background-color 0.3s;
      }
      
      #pause-toggle-button:active {
          transform: scale(0.95);
      }

      #pause-icon {
          font-size: 28px; /* é©åˆ‡ãªã‚µã‚¤ã‚ºã«èª¿æ•´ */
          line-height: 1;
      }
      #chara {
          position: absolute; 
  bottom: 10px;               /* ä¸Šç«¯ã‹ã‚‰10px */
  right: -60px;               /* å·¦ç«¯ã‹ã‚‰50%ã®ä½ç½® */
  z-index: 998; 
  width: 230px;            /* å››è§’ã®å¹… */
  height: 230px;            /* é«˜ã•è‡ªå‹• */
  color: #FFFFFF;          /* æ–‡å­—è‰²ã‚’ç™½ã« */
  font-family: monospace; 
  font-size: 14px; 
  background: rgba(0, 0, 0, 0); 
  padding: 10px; 
  text-align: center;      /* ä¸­å¤®æƒãˆ */
  background-image: url('yuki3.png');
    background-size: 250px auto; /* ã‚µã‚¤ã‚ºã‚’æŒ‡å®š */
    background-repeat: no-repeat; /* ç¹°ã‚Šè¿”ã—ã‚’ãªã—ã« */
    background-position: center top; /* ä½ç½®ã‚’æŒ‡å®š */
      }
          #maru1 {
          position: absolute; 
        bottom: 115px; /* å·¦ä¸Šã«å¤‰æ›´ */
        right: 115px;               /* å·¦ç«¯ã‹ã‚‰50%ã®ä½ç½® */
         transform: translateX(-50%); /* ä¸­å¤®ã«å¯„ã›ã‚‹ãŸã‚ã®èª¿æ•´ */
        z-index: 998; 
        width: 5px; 
        height: 5px;
        color: #2b2a54; 
        font-family: monospace; 
        font-size: 18px; 
        background: #FFFFFF; 
        padding: 10px; 
        white-space: pre-wrap; 
        text-align: center; /* å·¦å¯„ã›ã«å¤‰æ›´ */
        font-weight: bold; 
        border: 5px solid #2b2a54;
        border-radius: 50%;
      }
      #maru2 {
          position: absolute; 
        bottom: 160px; /* å·¦ä¸Šã«å¤‰æ›´ */
        right: 140px;               /* å·¦ç«¯ã‹ã‚‰50%ã®ä½ç½® */
         transform: translateX(-50%); /* ä¸­å¤®ã«å¯„ã›ã‚‹ãŸã‚ã®èª¿æ•´ */
        z-index: 998; 
        width: 25px; 
        height: 25px;
        color: #2b2a54; 
        font-family: monospace; 
        font-size: 18px; 
        background: #FFFFFF; 
        padding: 10px; 
        white-space: pre-wrap; 
        text-align: center; /* å·¦å¯„ã›ã«å¤‰æ›´ */
        font-weight: bold; 
        border: 5px solid #2b2a54;
        border-radius: 50%;
      }

    </style>
  </head>

  <body style="margin : 0px; overflow: hidden;">
    <div id="pause-toggle-button">
        <span id="pause-icon">â™ â™</span>
    </div>
    <div id="chara"></div>
    <div id="debug-div">ARçµåˆåˆ†æAI</div>
    <div id="analysis-div">è§£æä¸­...</div>
    <div id="new-info-panel">
    <p></p>
    <p></p>
  </div>
  <div id="new-info-panel2">
    <p></p>
    <p></p>
  </div>
  <div id="maru1">
    <p></p>
    <p></p>
  </div>
  <div id="maru2">
    <p></p>
    <p></p>
  </div>
    <a-scene embedded arjs="detectionMode: mono_and_matrix; matrixCodeType: 3x3; maxDetectionRate: 30;" bond-analyzer>
      <a-entity id="bond-group"></a-entity>
      
      <a-marker id="carbon-1" type="pattern" url="carbon-1.patt">
          <a-sphere color="#808080" radius="0.3"></a-sphere>
          
      </a-marker>
      <a-marker id="carbon-2" type="pattern" url="carbon-2.patt">
          <a-sphere color="#808080" radius="0.3"></a-sphere>
          
      </a-marker>
      <a-marker id="carbon-3" type="pattern" url="carbon-3.patt">
          <a-sphere color="#808080" radius="0.3"></a-sphere>
          
      </a-marker>
      <a-marker id="carbon-4" type="pattern" url="carbon-4.patt">
          <a-sphere color="#808080" radius="0.3"></a-sphere>
          
      </a-marker>
      <a-marker id="carbon-5" type="pattern" url="carbon-5.patt">
          <a-sphere color="#808080" radius="0.3"></a-sphere>
          
      </a-marker>
      <a-marker id="carbon-6" type="pattern" url="carbon-6.patt">
          <a-sphere color="#808080" radius="0.3"></a-sphere>
          
      </a-marker>
      <a-marker id="carbon-7" type="pattern" url="carbon-7.patt">
          <a-sphere color="#808080" radius="0.3"></a-sphere>
          
      </a-marker>
      
      <a-marker id="hydrogen-1" type="pattern" url="hydrogen-1.patt">
          <a-sphere color="#ADD8E6" radius="0.2"></a-sphere>
          
      </a-marker>
      <a-marker id="hydrogen-2" type="pattern" url="hydrogen-2.patt">
          <a-sphere color="#ADD8E6" radius="0.2"></a-sphere>
          
      </a-marker>
      <a-marker id="hydrogen-3" type="pattern" url="hydrogen-3.patt">
          <a-sphere color="#ADD8E6" radius="0.2"></a-sphere>
          
      </a-marker>
      <a-marker id="hydrogen-4" type="pattern" url="hydrogen-4.patt">
          <a-sphere color="#ADD8E6" radius="0.2"></a-sphere>
          
      </a-marker>
      <a-marker id="hydrogen-5" type="pattern" url="hydrogen-5.patt">
          <a-sphere color="#ADD8E6" radius="0.2"></a-sphere>
          
      </a-marker>
      <a-marker id="hydrogen-6" type="pattern" url="hydrogen-6.patt">
          <a-sphere color="#ADD8E6" radius="0.2"></a-sphere>
          
      </a-marker>
      <a-marker id="hydrogen-7" type="pattern" url="hydrogen-7.patt">
          <a-sphere color="#ADD8E6" radius="0.2"></a-sphere>
          
      </a-marker>
      
      <a-marker id="oxygen-1" type="pattern" url="oxygen-1.patt">
          <a-sphere color="#db6172" radius="0.3"></a-sphere>
          
      </a-marker>
      <a-marker id="oxygen-2" type="pattern" url="oxygen-2.patt">
          <a-sphere color="#db6172" radius="0.3"></a-sphere>
          
      </a-marker>
      
      <a-marker id="double-bond" type="pattern" url="double.patt"></a-marker>
      <a-marker id="triple-bond" type="pattern" url="triple.patt"></a-box></a-marker>
      <a-entity camera></a-entity>
    </a-scene>
  </body>
</html>